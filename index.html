<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Synced Video Player</title>
  <style>
    html, body { margin:0; padding:0; background:black; height:100%; overflow:hidden; }
    video { width:100%; height:100%; background:black; display: none; }
    video::-webkit-media-controls,
    video::-moz-media-controls { display:none!important; }
    #status {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      background: rgba(0,0,0,0.7);
      padding: 10px 15px;
      border-radius: 5px;
      font-family: Arial, sans-serif;
      font-size: 16px;
      z-index: 100;
      pointer-events: none;
      text-shadow: 1px 1px 2px black;
      opacity: 0;
      transition: opacity 0.3s;
    }
    #status.visible {
      opacity: 1;
    }
    #waiting-message {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: white;
      font-size: 24px;
      font-family: Arial, sans-serif;
      text-align: center;
      z-index: 90;
      background: rgba(0,0,0,0.7);
      padding: 20px 40px;
      border-radius: 10px;
    }
    #preload-video {
      display: none;
    }
    #current-track-info {
      position: absolute;
      bottom: 10px;
      right: 10px;
      color: rgba(255,255,255,0.7);
      background: rgba(0,0,0,0.5);
      padding: 5px 10px;
      border-radius: 3px;
      font-family: Arial, sans-serif;
      font-size: 12px;
      z-index: 90;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s;
    }
    #current-track-info.visible {
      opacity: 1;
    }
  </style>
</head>
<body>
  <video id="video" autoplay preload="auto">
    <!-- Source will be set dynamically -->
  </video>
  
  <!-- Hidden video for preloading main video -->
  <video id="preload-video" preload="auto"></video>
  
  <div id="status">Paused</div>
  <div id="waiting-message">Waiting for admin to launch playlist...</div>
  
  <!-- Subtle track information display (no controls) -->
  <div id="current-track-info"></div>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    const video = document.getElementById('video');
    const preloadVideo = document.getElementById('preload-video');
    const statusEl = document.getElementById('status');
    const waitingMessage = document.getElementById('waiting-message');
    const trackInfoEl = document.getElementById('current-track-info');
    
    const socket = io();
    
    // Get config from server
    socket.on('config', (config) => {
      skipSeconds = config.skipSeconds || 5;
      volumeStep = config.volumeStep || 0.05;
    });
    
    // State variables
    let currentPlaylist = { videos: [], currentIndex: 0, mainVideoIndex: -1 };
    let mainVideoStartTime = 0;
    let lastUpdate = 0;
    let uiTimeout = null;
    let trackInfoTimeout = null;
    let skipSeconds = 5; // Default value
    let volumeStep = 0.05; // Default value (5%)
    let currentAudioTrack = 0;
    let currentSubtitleTrack = -1;
    let currentVideoInfo = null;
    let videoLoadAttempts = 0;
    const maxVideoLoadAttempts = 3;
    
    video.volume = 0.5;
    preloadVideo.volume = 0; // Mute preload video
    
    // Initially show waiting message and hide video
    waitingMessage.style.display = 'block';
    video.style.display = 'none';
    
    // UI functions
    function showTemporaryMessage(message, duration = 2000) {
      clearTimeout(uiTimeout);
      statusEl.textContent = message;
      statusEl.classList.add('visible');
      
      if (duration > 0) {
        uiTimeout = setTimeout(() => {
          statusEl.classList.remove('visible');
        }, duration);
      }
    }
    
    function showTrackInfo(message, duration = 3000) {
      clearTimeout(trackInfoTimeout);
      trackInfoEl.textContent = message;
      trackInfoEl.classList.add('visible');
      
      if (duration > 0) {
        trackInfoTimeout = setTimeout(() => {
          trackInfoEl.classList.remove('visible');
        }, duration);
      }
    }
    
    // Send control event to server
    function sendControlEvent() {
      socket.emit('control', {
        isPlaying: !video.paused,
        currentTime: video.currentTime
      });
    }
    
    // Handle playlist updates from server
    socket.on('playlist-update', (playlist) => {
      currentPlaylist = playlist;
      mainVideoStartTime = playlist.mainVideoStartTime || 0;
      
      // Preload main video if specified
      if (playlist.mainVideoIndex >= 0 && playlist.videos.length > playlist.mainVideoIndex) {
        const mainVideo = playlist.videos[playlist.mainVideoIndex];
        preloadVideo.src = `/videos/${mainVideo.filename}`;
        preloadVideo.load();
        console.log('Preloading main video:', mainVideo.filename);
      }
      
      // Only hide waiting message if we have videos to play
      if (currentPlaylist.videos.length > 0 && currentPlaylist.currentIndex >= 0) {
        // Hide waiting message and show video
        waitingMessage.style.display = 'none';
        video.style.display = 'block';
        
        // Load the current video
        loadCurrentVideo();
      } else {
        // Show waiting message if no videos available
        waitingMessage.style.display = 'block';
        video.style.display = 'none';
      }
    });

    // Handle playlist position updates from server
    socket.on('playlist-position', (index) => {
      currentPlaylist.currentIndex = index;
      
      // Only proceed if we have videos
      if (currentPlaylist.videos.length > 0 && index >= 0) {
        // Hide waiting message if it's still showing
        waitingMessage.style.display = 'none';
        video.style.display = 'block';
        
        loadCurrentVideo();
      } else {
        // Show waiting message if no videos
        waitingMessage.style.display = 'block';
        video.style.display = 'none';
      }
    });

    // Handle video ending and move to next in playlist
    video.addEventListener('ended', () => {
      if (currentPlaylist.videos.length > 0) {
        // Move to next video in playlist
        const nextIndex = (currentPlaylist.currentIndex + 1) % currentPlaylist.videos.length;
        
        // Notify server to update playlist position
        socket.emit('playlist-next', nextIndex);
      }
    });

    // Load the current video based on playlist position
    function loadCurrentVideo() {
      if (currentPlaylist.videos.length === 0 || currentPlaylist.currentIndex < 0) {
        // Show waiting message if no videos
        waitingMessage.style.display = 'block';
        video.style.display = 'none';
        return;
      }
      
      const currentVideo = currentPlaylist.videos[currentPlaylist.currentIndex];
      currentVideoInfo = currentVideo;
      
      video.src = `/videos/${currentVideo.filename}`;
      
      // If this is the main video, set the start time
      if (currentPlaylist.currentIndex === currentPlaylist.mainVideoIndex) {
        video.currentTime = mainVideoStartTime;
      } else {
        video.currentTime = 0;
      }
      
      video.load();
      
      video.onloadeddata = function() {
        videoLoadAttempts = 0; // Reset attempts on successful load
        
        if (!video.paused) {
          video.play().catch(e => {
            console.log('Playback error:', e);
            handlePlaybackError(e);
          });
        }
      };
      
      video.onerror = function() {
        console.log('Error loading video:', currentVideo.filename);
        videoLoadAttempts++;
        
        if (videoLoadAttempts < maxVideoLoadAttempts) {
          // Retry loading the video
          setTimeout(() => {
            console.log('Retrying video load, attempt:', videoLoadAttempts);
            loadCurrentVideo();
          }, 1000);
        } else {
          // Show waiting message if video fails to load
          waitingMessage.style.display = 'block';
          video.style.display = 'none';
          showTemporaryMessage('Failed to load video. Please check file format.', 5000);
        }
      };
    }
    
    // Handle playback errors
    function handlePlaybackError(error) {
      console.log('Playback error:', error);
      
      // Show waiting message if playback fails
      waitingMessage.style.display = 'block';
      video.style.display = 'none';
      showTemporaryMessage('Playback failed. Please check file format.', 3000);
    }
    
    // Handle server sync events
    socket.on('sync', (state) => {
      // Prevent feedback loops
      const now = Date.now();
      if (now - lastUpdate < 100) return;
      lastUpdate = now;
      
      // Sync playback state
      if (state.isPlaying !== !video.paused) {
        if (state.isPlaying) {
          video.play().catch(e => {
            console.log('Playback error:', e);
            handlePlaybackError(e);
          });
        } else {
          video.pause();
          showTemporaryMessage("Paused", 0);
        }
      }
      
      // Sync time position
      if (Math.abs(video.currentTime - state.currentTime) > 0.5) {
        video.currentTime = state.currentTime;
      }
      
      // Sync audio track (just display info, no control)
      if (state.audioTrack !== undefined && state.audioTrack !== currentAudioTrack) {
        currentAudioTrack = state.audioTrack;
        if (currentVideoInfo && currentVideoInfo.tracks && currentVideoInfo.tracks.audio) {
          const audioTrack = currentVideoInfo.tracks.audio[currentAudioTrack];
          if (audioTrack) {
            showTrackInfo(`Audio: ${audioTrack.language} ${audioTrack.title ? `- ${audioTrack.title}` : ''}`);
          }
        }
      }
      
      // Sync subtitle track (just display info, no control)
      if (state.subtitleTrack !== undefined && state.subtitleTrack !== currentSubtitleTrack) {
        currentSubtitleTrack = state.subtitleTrack;
        if (currentSubtitleTrack >= 0 && currentVideoInfo && currentVideoInfo.tracks && currentVideoInfo.tracks.subtitles) {
          const subtitleTrack = currentVideoInfo.tracks.subtitles[currentSubtitleTrack];
          if (subtitleTrack) {
            showTrackInfo(`Subtitles: ${subtitleTrack.language} ${subtitleTrack.title ? `- ${subtitleTrack.title}` : ''}`);
          }
        } else if (currentSubtitleTrack < 0) {
          showTrackInfo("Subtitles: Off");
        }
      }
    });
    
    // Event listeners
    video.addEventListener('play', () => {
      statusEl.classList.remove('visible');
      sendControlEvent();
    });
    
    video.addEventListener('pause', () => {
      showTemporaryMessage("Paused", 0);
      sendControlEvent();
    });
    
    video.addEventListener('seeked', sendControlEvent);
    
    // Control zones
    document.addEventListener('click', (e) => {
      const w = window.innerWidth;
      const x = e.clientX;
      const center = w / 2;
      const edgeZone = 87;
      const pauseZone = 75;
      
      // Left edge: Rewind
      if (x <= edgeZone) {
        video.currentTime = Math.max(0, video.currentTime - skipSeconds);
        showTemporaryMessage(`↩ Rewind ${skipSeconds}s`);
        sendControlEvent();
      } 
      // Right edge: Skip
      else if (x >= w - edgeZone) {
        video.currentTime = Math.min(video.duration, video.currentTime + skipSeconds);
        showTemporaryMessage(`↪ Skip ${skipSeconds}s`);
        sendControlEvent();
      }
      // Center: Play/Pause
      else if (x >= center - pauseZone && x <= center + pauseZone) {
        if (video.paused) {
          video.play();
        } else {
          video.pause();
        }
      }
      // Left half: Volume Down
      else if (x < center) {
        video.volume = Math.max(0, video.volume - volumeStep);
        showTemporaryMessage(`Volume: ${Math.round(video.volume * 100)}%`);
      }
      // Right half: Volume Up
      else {
        video.volume = Math.min(1, video.volume + volumeStep);
        showTemporaryMessage(`Volume: ${Math.round(video.volume * 100)}%`);
      }
    });
    
    // Auto-reconnect
    setInterval(() => {
      if (!socket.connected) {
        socket.connect();
        showTemporaryMessage("Reconnecting...");
      }
    }, 5000);
  </script>
</body>
</html>
