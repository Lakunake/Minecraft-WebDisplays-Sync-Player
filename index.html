<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Synced Video Player</title>
  <style>
    html,
    body {
      margin: 0;
      padding: 0;
      background: black;
      height: 100%;
      overflow: hidden;
    }

    video {
      width: 100%;
      height: 100%;
      background: black;
      display: none;
    }

    video::-webkit-media-controls,
    video::-moz-media-controls {
      display: none !important;
    }

    #status {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      background: rgba(0, 0, 0, 0.7);
      padding: 10px 15px;
      border-radius: 5px;
      font-family: Arial, sans-serif;
      font-size: 16px;
      z-index: 100;
      pointer-events: none;
      text-shadow: 1px 1px 2px black;
      opacity: 0;
      transition: opacity 0.3s;
    }

    #status.visible {
      opacity: 1;
    }

    #waiting-message {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: white;
      font-size: 24px;
      font-family: Arial, sans-serif;
      text-align: center;
      z-index: 90;
      background: rgba(0, 0, 0, 0.7);
      padding: 20px 40px;
      border-radius: 10px;
    }

    #preload-video {
      display: none;
    }

    #current-track-info {
      position: absolute;
      bottom: 10px;
      right: 10px;
      color: rgba(255, 255, 255, 0.7);
      background: rgba(0, 0, 0, 0.5);
      padding: 5px 10px;
      border-radius: 3px;
      font-family: Arial, sans-serif;
      font-size: 12px;
      z-index: 90;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s;
    }

    #current-track-info.visible {
      opacity: 1;
    }
  </style>
</head>

<body>
  <video id="video" autoplay preload="auto"></video>
  <video id="preload-video" preload="auto"></video>

  <div id="waiting-message">Waiting for admin to launch playlist...</div>
  <div id="status"></div>
  <div id="current-track-info"></div>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    const video = document.getElementById('video');
    const preloadVideo = document.getElementById('preload-video');
    const waitingMessage = document.getElementById('waiting-message');
    const statusEl = document.getElementById('status');
    const currentTrackInfoEl = document.getElementById('current-track-info');

    const socket = io();

    let currentPlaylist = {
      videos: [],
      currentIndex: -1,
      mainVideoIndex: -1,
    };
    let currentVideoInfo = null;
    let mainVideoStartTime = 0;
    let videoLoadAttempts = 0;
    const maxVideoLoadAttempts = 3;
    let lastAppliedAudioTrack = null;
    let lastAppliedSubtitleTrack = null;
    let currentAudioTrack = null;
    let currentSubtitleTrack = null;

    const skipSeconds = 10;
    const volumeStep = 0.05;

    let lastUpdate = Date.now();
    let hasInitialSync = false; // Prevent new clients from broadcasting until synced

    function showTemporaryMessage(message, duration = 2000) {
      statusEl.textContent = message;
      statusEl.classList.add('visible');
      if (duration > 0) {
        setTimeout(() => statusEl.classList.remove('visible'), duration);
      }
    }

    function showTrackInfo(message, duration = 3000) {
      currentTrackInfoEl.textContent = message;
      currentTrackInfoEl.classList.add('visible');
      setTimeout(() => currentTrackInfoEl.classList.remove('visible'), duration);
    }

    // Send control event to server - ONLY if we have received initial sync
    function sendControlEvent() {
      if (!hasInitialSync) {
        console.log('Skipping control event - waiting for initial sync');
        return;
      }
      socket.emit('control', {
        isPlaying: !video.paused,
        currentTime: video.currentTime,
        duration: video.duration,
        volume: video.volume,
        currentVideoIndex: currentPlaylist.currentIndex,
      });
    }

    socket.on('connect', () => {
      console.log('Connected to server');
      showTemporaryMessage('Connected', 1000);
      socket.emit('request-initial-state');
    });

    socket.on('disconnect', () => {
      console.log('Disconnected from server');
      showTemporaryMessage('Disconnected', 0);
      hasInitialSync = false; // Reset on disconnect
    });

    // Handle initial state from server
    socket.on('initial-state', (state) => {
      console.log('Received initial state:', state);
      currentPlaylist = state.playlist;
      mainVideoStartTime = state.mainVideoStartTime || 0;

      if (currentPlaylist.videos.length > 0) {
        const videoToPreload = (currentPlaylist.mainVideoIndex >= 0 && currentPlaylist.videos.length > currentPlaylist.mainVideoIndex)
          ? currentPlaylist.videos[currentPlaylist.mainVideoIndex]
          : currentPlaylist.videos[0];
        preloadVideo.src = `/videos/${videoToPreload.filename}`;
        preloadVideo.load();
      }

      if (currentPlaylist.videos.length > 0 && currentPlaylist.currentIndex >= 0) {
        waitingMessage.style.display = 'none';
        video.style.display = 'block';
        hasInitialSync = true;
        loadCurrentVideo();
      } else {
        waitingMessage.style.display = 'block';
        video.style.display = 'none';
      }
    });

    socket.on('playlist-position', (index) => {
      currentPlaylist.currentIndex = index;
      if (currentPlaylist.videos.length > 0 && index >= 0) {
        waitingMessage.style.display = 'none';
        video.style.display = 'block';
        hasInitialSync = true;
        loadCurrentVideo();
      } else {
        waitingMessage.style.display = 'block';
        video.style.display = 'none';
      }
    });

    socket.on('playlist-update', (playlist) => {
      console.log('Received playlist update:', playlist);
      currentPlaylist = playlist;

      if (currentPlaylist.videos.length > 0 && currentPlaylist.currentIndex >= 0) {
        waitingMessage.style.display = 'none';
        video.style.display = 'block';
        hasInitialSync = true;
        loadCurrentVideo();
      } else {
        waitingMessage.style.display = 'block';
        video.style.display = 'none';
      }
    });

    socket.on('track-change', (data) => {
      if (currentPlaylist.videos.length > 0 && data.videoIndex < currentPlaylist.videos.length) {
        const videoItem = currentPlaylist.videos[data.videoIndex];

        if (data.type === 'audio') {
          videoItem.selectedAudioTrack = data.trackIndex;
        } else if (data.type === 'subtitle') {
          videoItem.selectedSubtitleTrack = data.trackIndex;
        }

        if (data.videoIndex === currentPlaylist.currentIndex) {
          currentVideoInfo = videoItem;
          applyTrackSelectionsDelayed();

          const trackInfo = data.type === 'audio'
            ? (videoItem.tracks && videoItem.tracks.audio && videoItem.tracks.audio[data.trackIndex]
              ? `${videoItem.tracks.audio[data.trackIndex].language} - ${videoItem.tracks.audio[data.trackIndex].title || `Track ${data.trackIndex}`}`
              : `Audio Track ${data.trackIndex}`)
            : (data.trackIndex >= 0 && videoItem.tracks && videoItem.tracks.subtitles && videoItem.tracks.subtitles[data.trackIndex]
              ? `${videoItem.tracks.subtitles[data.trackIndex].language} - ${videoItem.tracks.subtitles[data.trackIndex].title || `Track ${data.trackIndex}`}`
              : 'Subtitles Off');

          showTrackInfo(`${data.type === 'audio' ? 'Audio' : 'Subtitles'}: ${trackInfo}`);
        }
      }
    });

    video.addEventListener('ended', () => {
      if (currentPlaylist.videos.length > 0) {
        const nextIndex = (currentPlaylist.currentIndex + 1) % currentPlaylist.videos.length;
        socket.emit('playlist-next', nextIndex);
      }
    });

    function loadCurrentVideo() {
      if (currentPlaylist.videos.length === 0 || currentPlaylist.currentIndex < 0) {
        waitingMessage.style.display = 'block';
        video.style.display = 'none';
        return;
      }

      const currentVideo = currentPlaylist.videos[currentPlaylist.currentIndex];
      currentVideoInfo = currentVideo;

      let videoSrc = `/videos/${currentVideo.filename}`;
      console.log('Loading video:', videoSrc);
      video.src = videoSrc;

      // Request sync from server to get the current time
      socket.emit('request-sync');

      clearVideoTracks();
      video.load();

      video.onloadeddata = function () {
        videoLoadAttempts = 0;
        applyTrackSelections();

        if (!video.paused) {
          video.play().catch(e => {
            console.log('Playback error:', e);
            handlePlaybackError(e);
          });
        }
      };

      video.onloadedmetadata = function () {
        applyTrackSelections();
      };

      video.onerror = function () {
        console.log('Error loading video:', currentVideo.filename);
        videoLoadAttempts++;

        if (videoLoadAttempts < maxVideoLoadAttempts) {
          setTimeout(() => {
            console.log('Retrying video load, attempt:', videoLoadAttempts);
            loadCurrentVideo();
          }, 1000);
        } else {
          waitingMessage.style.display = 'block';
          video.style.display = 'none';
          showTemporaryMessage('Failed to load video. Please check file format.', 5000);
        }
      };
    }

    function handlePlaybackError(error) {
      console.log('Playback error:', error);
      waitingMessage.style.display = 'block';
      video.style.display = 'none';
      showTemporaryMessage('Playback failed. Please check file format.', 3000);
    }

    function clearVideoTracks() {
      const audioTracks = video.audioTracks;
      const textTracks = video.textTracks;

      if (audioTracks) {
        for (let i = 0; i < audioTracks.length; i++) {
          audioTracks[i].enabled = false;
        }
      }

      if (textTracks) {
        for (let i = 0; i < textTracks.length; i++) {
          textTracks[i].mode = 'disabled';
        }
      }
    }

    function applyTrackSelections() {
      if (!currentVideoInfo) return;
      tryDirectTrackManipulation();
      tryVideoAttributes();
    }

    function tryDirectTrackManipulation() {
      if (typeof video.audioTracks !== 'undefined' && currentVideoInfo.selectedAudioTrack !== undefined) {
        const targetIndex = Math.max(0, Math.min(currentVideoInfo.selectedAudioTrack, video.audioTracks.length - 1));
        if (lastAppliedAudioTrack !== targetIndex) {
          for (let i = 0; i < video.audioTracks.length; i++) {
            video.audioTracks[i].enabled = (i === targetIndex);
          }
          lastAppliedAudioTrack = targetIndex;
        }
      }

      if (typeof video.textTracks !== 'undefined' && currentVideoInfo.selectedSubtitleTrack !== undefined) {
        const targetSubIndex = currentVideoInfo.selectedSubtitleTrack;
        if (lastAppliedSubtitleTrack !== targetSubIndex) {
          for (let i = 0; i < video.textTracks.length; i++) {
            if (targetSubIndex >= 0) {
              video.textTracks[i].mode = (i === targetSubIndex) ? 'showing' : 'disabled';
            } else {
              video.textTracks[i].mode = 'disabled';
            }
          }
          lastAppliedSubtitleTrack = targetSubIndex;
        }
      }
    }

    function tryVideoAttributes() {
      if (currentVideoInfo.selectedAudioTrack !== undefined) {
        video.setAttribute('data-audio-track', currentVideoInfo.selectedAudioTrack);
      }
      if (currentVideoInfo.selectedSubtitleTrack !== undefined) {
        video.setAttribute('data-subtitle-track', currentVideoInfo.selectedSubtitleTrack);
      }
    }

    function applyTrackSelectionsDelayed() {
      setTimeout(() => applyTrackSelections(), 500);
    }

    // Handle server sync events
    socket.on('sync', (state) => {
      const now = Date.now();
      if (now - lastUpdate < 100) return;
      lastUpdate = now;

      // If we receive a sync and have an active playlist, hide waiting message
      if (currentPlaylist.videos.length > 0 && currentPlaylist.currentIndex >= 0) {
        if (waitingMessage.style.display !== 'none') {
          console.log('Hiding waiting message - active playlist detected');
          waitingMessage.style.display = 'none';
          video.style.display = 'block';
          hasInitialSync = true;
        }
      }

      if (state.isPlaying !== !video.paused) {
        if (state.isPlaying) {
          video.play().catch(e => {
            console.log('Playback error:', e);
            handlePlaybackError(e);
          });
        } else {
          video.pause();
          showTemporaryMessage("Paused", 0);
        }
      }

      if (Math.abs(video.currentTime - state.currentTime) > 0.5) {
        video.currentTime = state.currentTime;
      }

      if (state.audioTrack !== undefined && state.audioTrack !== currentAudioTrack) {
        currentAudioTrack = state.audioTrack;
        if (currentVideoInfo && currentVideoInfo.tracks && currentVideoInfo.tracks.audio) {
          const audioTrack = currentVideoInfo.tracks.audio[currentAudioTrack];
          if (audioTrack) {
            showTrackInfo(`Audio: ${audioTrack.language}${audioTrack.title ? ` - ${audioTrack.title}` : ''}`);
          }
        }
      }

      if (state.subtitleTrack !== undefined && state.subtitleTrack !== currentSubtitleTrack) {
        currentSubtitleTrack = state.subtitleTrack;
        if (currentSubtitleTrack >= 0 && currentVideoInfo && currentVideoInfo.tracks && currentVideoInfo.tracks.subtitles) {
          const subtitleTrack = currentVideoInfo.tracks.subtitles[currentSubtitleTrack];
          if (subtitleTrack) {
            showTrackInfo(`Subtitles: ${subtitleTrack.language}${subtitleTrack.title ? ` - ${subtitleTrack.title}` : ''}`);
          }
        } else if (currentSubtitleTrack < 0) {
          showTrackInfo("Subtitles: Off");
        }
      }
    });

    // Event listeners - only send control if we have initial sync
    video.addEventListener('play', () => {
      statusEl.classList.remove('visible');
      sendControlEvent();
    });

    video.addEventListener('pause', () => {
      showTemporaryMessage("Paused", 0);
      sendControlEvent();
    });

    video.addEventListener('seeked', sendControlEvent);

    // Control zones (click on screen)
    document.addEventListener('click', (e) => {
      const w = window.innerWidth;
      const x = e.clientX;
      const center = w / 2;
      const edgeZone = 87;
      const pauseZone = 75;

      if (x <= edgeZone) {
        video.currentTime = Math.max(0, video.currentTime - skipSeconds);
        showTemporaryMessage(`↩ Rewind ${skipSeconds}s`);
        sendControlEvent();
      } else if (x >= w - edgeZone) {
        video.currentTime = Math.min(video.duration, video.currentTime + skipSeconds);
        showTemporaryMessage(`↪ Skip ${skipSeconds}s`);
        sendControlEvent();
      } else if (x >= center - pauseZone && x <= center + pauseZone) {
        if (video.paused) {
          video.play();
        } else {
          video.pause();
        }
      } else if (x < center) {
        video.volume = Math.max(0, video.volume - volumeStep);
        showTemporaryMessage(`Volume: ${Math.round(video.volume * 100)}%`);
      } else {
        video.volume = Math.min(1, video.volume + volumeStep);
        showTemporaryMessage(`Volume: ${Math.round(video.volume * 100)}%`);
      }
    });

    // Auto-reconnect
    setInterval(() => {
      if (!socket.connected) {
        socket.connect();
        showTemporaryMessage("Reconnecting...");
      }
    }, 5000);
  </script>
</body>

</html>
