<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Sync-Player Admin Panel</title>
  <link rel="icon" href="data:,">
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    :root {
      scroll-behavior: smooth;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #0a0a1a 0%, #1a1a2e 50%, #16213e 100%);
      color: #e0e0e0;
      min-height: 100vh;
      display: flex;
    }

    /* Glassmorphism Base */
    .glass {
      background: rgba(255, 255, 255, 0.05);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
    }

    .glass-strong {
      background: rgba(255, 255, 255, 0.08);
      backdrop-filter: blur(15px);
      -webkit-backdrop-filter: blur(15px);
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-radius: 12px;
    }

    /* Sidebar */
    .sidebar {
      width: 70px;
      background: rgba(10, 10, 30, 0.8);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border-right: 1px solid rgba(255, 255, 255, 0.1);
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px 0;
      gap: 10px;
      position: relative;
      z-index: 1000;
    }

    .sidebar-logo {
      width: 40px;
      height: 40px;
      background: linear-gradient(135deg, #2196F3 0%, #1565C0 100%);
      border-radius: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      font-size: 18px;
      margin-bottom: 20px;
      box-shadow: 0 0 20px rgba(33, 150, 243, 0.4);
    }

    .nav-item {
      width: 50px;
      height: 50px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.3s ease;
      font-size: 22px;
      color: #888;
      position: relative;
    }

    .nav-item:hover {
      background: rgba(33, 150, 243, 0.2);
      color: #2196F3;
    }

    .nav-item.active {
      background: rgba(33, 150, 243, 0.3);
      color: #2196F3;
      box-shadow: 0 0 20px rgba(33, 150, 243, 0.3);
    }

    /* Sliding nav indicator */
    .nav-indicator {
      position: absolute;
      left: 0;
      top: 0;
      /* JavaScript will set the correct position */
      width: 4px;
      height: 30px;
      background: #2196F3;
      border-radius: 2px;
      box-shadow: 0 0 10px #2196F3;
      transition: top 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .nav-tooltip {
      position: absolute;
      left: 70px;
      background: rgba(33, 150, 243, 0.95);
      color: white;
      padding: 8px 14px;
      border-radius: 6px;
      font-size: 13px;
      white-space: nowrap;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s;
      z-index: 9999;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
    }

    .nav-item:hover .nav-tooltip {
      opacity: 1;
    }

    /* Main Content */
    .main-content {
      flex: 1;
      padding: 20px;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    /* Header */
    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 15px 20px;
      position: relative;
      z-index: 10;
    }

    .header h1 {
      font-size: 24px;
      font-weight: 600;
      color: #fff;
    }

    .header h1 span {
      color: #2196F3;
    }

    .status-group {
      display: flex;
      align-items: center;
      gap: 15px;
      flex: 1;
      justify-content: flex-end;
      margin-left: 20px;
    }

    .connection-status {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 16px;
      border-radius: 20px;
      font-size: 14px;
    }

    .status-dot {
      width: 10px;
      height: 10px;
      background: #4CAF50;
      border-radius: 50%;
      box-shadow: 0 0 10px #4CAF50;
      animation: pulse 2s infinite;
    }

    @keyframes pulse {

      0%,
      100% {
        opacity: 1;
      }

      50% {
        opacity: 0.5;
      }
    }

    .status-dot.offline {
      background: #f44336;
      box-shadow: 0 0 10px #f44336;
      animation: none;
    }

    /* Dashboard Grid */
    .dashboard-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 20px;
    }

    .dashboard-main {
      display: flex;
      gap: 20px;
      flex: 1;
    }

    .stat-card {
      padding: 20px;
      display: flex;
      align-items: center;
      gap: 15px;
    }

    .stat-icon {
      width: 50px;
      height: 50px;
      border-radius: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
    }

    .stat-icon.blue {
      background: rgba(33, 150, 243, 0.2);
      color: #2196F3;
      box-shadow: 0 0 20px rgba(33, 150, 243, 0.2);
    }

    .stat-icon.purple {
      background: rgba(156, 39, 176, 0.2);
      color: #9C27B0;
      box-shadow: 0 0 20px rgba(156, 39, 176, 0.2);
    }

    .stat-icon.cyan {
      background: rgba(0, 188, 212, 0.2);
      color: #00BCD4;
      box-shadow: 0 0 20px rgba(0, 188, 212, 0.2);
    }

    .stat-info h3 {
      font-size: 24px;
      font-weight: 600;
      color: #fff;
    }

    .stat-info p {
      font-size: 13px;
      color: #888;
    }

    /* Panels */
    .panel {
      padding: 20px;
    }

    .panel-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
      padding-bottom: 15px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    .panel-header h2 {
      font-size: 18px;
      font-weight: 600;
      color: #fff;
    }

    /* Content Views - Scroll-like animation, one view at a time */
    .view {
      display: none;
      flex-direction: column;
      gap: 20px;
      flex: 1;
      will-change: transform, opacity;
    }

    .view.active {
      display: flex;
      animation: scrollIn 0.25s ease-out;
    }

    .view.scroll-down.active {
      animation: scrollInFromTop 0.15s ease-out;
    }

    .view.scroll-up.active {
      animation: scrollInFromBottom 0.25s ease-out;
    }

    @keyframes scrollInFromTop {
      from {
        opacity: 0;
        transform: translateY(-30px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @keyframes scrollInFromBottom {
      from {
        opacity: 0;
        transform: translateY(100px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    /* Media/Playlist Section */
    .media-playlist-layout {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      flex: 1;
    }

    .file-list {
      max-height: 400px;
      overflow-y: auto;
      overflow-x: hidden;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .file-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 15px;
      background: rgba(255, 255, 255, 0.03);
      border-radius: 8px;
      transition: all 0.2s;
    }

    .file-item:hover {
      background: rgba(33, 150, 243, 0.1);
    }

    .file-name {
      font-size: 14px;
      display: flex;
      align-items: center;
      gap: 10px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      flex: 1;
    }

    .file-icon {
      color: #2196F3;
    }

    /* Playlist Items */
    .playlist-item {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px 15px;
      background: rgba(255, 255, 255, 0.03);
      border-radius: 8px;
      transition: all 0.2s;
      border-left: 3px solid transparent;
      position: relative;
      overflow: hidden;
      will-change: transform, opacity;
    }

    .playlist-item.slide-in {
      animation: slideInFromRight 0.3s ease-out;
    }

    @keyframes slideInFromRight {
      from {
        opacity: 0;
        transform: translateX(100%);
      }

      to {
        opacity: 1;
        transform: translateX(0);
      }
    }

    .playlist-item.slide-out {
      animation: slideOutAndCollapse 0.4s ease-out forwards;
      pointer-events: none;
    }

    @keyframes slideOutAndCollapse {
      0% {
        opacity: 1;
        transform: translateX(0);
        max-height: 100px;
        margin-bottom: 8px;
        padding: 12px 15px;
      }

      50% {
        opacity: 0;
        transform: translateX(100%);
        max-height: 100px;
        margin-bottom: 8px;
        padding: 12px 15px;
      }

      100% {
        opacity: 0;
        transform: translateX(100%);
        max-height: 0;
        margin-bottom: 0;
        padding: 0 15px;
      }
    }

    .playlist-item .thumbnail-bg {
      position: absolute;
      /* Take a strip from the middle - DO NOT CHANGE */
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-size: cover;
      background-position: center;
      opacity: 0;
      filter: blur(10px);
      transition: opacity 0.5s ease-out, filter 0.5s ease-out;
      z-index: 0;
    }

    .playlist-item .thumbnail-bg.loaded {
      opacity: 0.5;
    }

    /* Cached thumbnails appear instantly, no opacity fade */
    .playlist-item .thumbnail-bg.cached {
      opacity: 0.5;
      transition: filter 0.25s ease-out;
      /* Fast blur-in when deselected */
    }

    .playlist-item .thumbnail-bg.themed {
      opacity: 1;
      filter: none;
    }

    .playlist-item>*:not(.thumbnail-bg) {
      position: relative;
      z-index: 1;
    }

    .playlist-item:hover {
      background: rgba(33, 150, 243, 0.1);
    }

    .playlist-item.main {
      background: rgba(33, 150, 243, 0.15);
      border-left-color: #2196F3;
    }

    /* Clear blur only when explicitly cleared (allows animation) */
    .playlist-item.main .thumbnail-bg.cleared {
      opacity: 0.5;
      filter: blur(0);
      transition: filter 0.5s ease-out;
      /* Slower blur-out when selected */
    }

    .playlist-item.current {
      background: rgba(156, 39, 176, 0.15);
      border-left-color: #9C27B0;
    }

    .playlist-number {
      width: 28px;
      height: 28px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      color: #888;
    }

    .playlist-item.current .playlist-number {
      background: #9C27B0;
      color: white;
    }

    .playlist-name {
      flex: 1;
      font-size: 14px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      position: relative;
    }

    .playlist-name span {
      display: inline-block;
      padding-right: 2em;
    }

    /* Auto-scroll for currently playing video (slower) */
    .playlist-item.current .playlist-name span {
      animation: scroll-text 15s linear infinite;
      will-change: transform;
    }

    /* Faster scroll on hover - applies to ALL items including current */
    .playlist-item:hover .playlist-name span {
      animation: scroll-text 8s linear infinite !important;
      will-change: transform;
    }

    @keyframes scroll-text {
      0% {
        transform: translateX(0%);
      }

      100% {
        transform: translateX(-50%);
      }
    }

    .playlist-badges {
      display: flex;
      gap: 6px;
    }

    .badge {
      padding: 2px 6px;
      border-radius: 8px;
      font-size: 9px;
      font-weight: 600;
      pointer-events: none;
      letter-spacing: 0.5px;
      text-transform: uppercase;
    }

    .badge-main {
      background: rgba(33, 150, 243, 0.3);
      color: #2196F3;
    }

    .badge-youtube {
      background: rgba(255, 0, 0, 0.3);
      color: #FF0000;
    }

    .badge-playing {
      background: rgba(156, 39, 176, 0.3);
      color: #9C27B0;
    }

    .badge-image {
      background: rgba(76, 175, 80, 0.3);
      color: #4CAF50;
    }

    .badge-vimeo {
      background: rgba(0, 173, 239, 0.3);
      color: #00ADEF;
    }

    .badge-twitch {
      background: rgba(145, 70, 255, 0.3);
      color: #9146FF;
    }

    .badge-dailymotion {
      background: rgba(0, 100, 178, 0.3);
      color: #0064B2;
    }

    .badge-soundcloud {
      background: rgba(255, 85, 0, 0.3);
      color: #FF5500;
    }

    .badge-streamable {
      background: rgba(13, 149, 229, 0.3);
      color: #0D95E5;
    }

    .badge-gdrive {
      background: rgba(66, 133, 244, 0.3);
      color: #4285F4;
    }

    .badge-kick {
      background: rgba(83, 252, 24, 0.3);
      color: #53FC18;
    }

    .badge-url {
      background: rgba(128, 128, 128, 0.3);
      color: #808080;
    }

    .badge-audio {
      background: rgba(255, 152, 0, 0.3);
      color: #FF9800;
    }

    .badge-iframe {
      background: rgba(255, 193, 7, 0.3);
      color: #FFC107;
    }

    .badge-rumble {
      background: rgba(136, 176, 75, 0.3);
      color: #88b04b;
    }

    .move-buttons {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .btn-move {
      background: rgba(255, 255, 255, 0.1);
      border: none;
      color: #888;
      padding: 4px 8px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 10px;
      transition: all 0.2s;
    }

    .btn-move:hover {
      background: rgba(33, 150, 243, 0.3);
      color: #2196F3;
    }

    .btn-move:disabled {
      opacity: 0.3;
      cursor: not-allowed;
    }

    /* Buttons */
    .btn {
      padding: 10px 20px;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .btn-primary {
      background: linear-gradient(135deg, #2196F3 0%, #1565C0 100%);
      color: white;
      box-shadow: 0 4px 15px rgba(33, 150, 243, 0.3);
    }

    .btn-primary:hover {
      box-shadow: 0 6px 20px rgba(33, 150, 243, 0.5);
      transform: translateY(-2px);
    }

    .btn-secondary {
      background: rgba(255, 255, 255, 0.1);
      color: #e0e0e0;
    }

    .btn-secondary:hover {
      background: rgba(255, 255, 255, 0.2);
    }

    .btn-success {
      background: linear-gradient(135deg, #4CAF50 0%, #388E3C 100%);
      color: white;
    }

    .btn-danger {
      background: rgba(244, 67, 54, 0.2);
      color: #f44336;
    }

    .btn-danger:hover {
      background: rgba(244, 67, 54, 0.3);
    }

    .btn-sm {
      padding: 6px 12px;
      font-size: 12px;
    }

    .btn:active,
    .nav-item:active,
    .quick-btn:active,
    .control-btn:active,
    .btn-move:active {
      transform: scale(0.95) !important;
    }

    /* Remote Control Section - 3 Column Layout */
    .remote-layout {
      display: grid;
      grid-template-columns: 320px 1fr 280px;
      grid-template-rows: 1fr auto;
      gap: 20px;
      flex: 1;
      min-height: 0;
    }

    .remote-playlist-panel {
      grid-row: span 2;
    }

    .remote-thumbnail-panel {
      display: flex;
      flex-direction: column;
    }

    .remote-controls-panel {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .remote-bottom-panel {
      grid-column: 2 / 4;
    }

    .current-video-card {
      display: flex;
      flex-direction: column;
    }

    .video-thumbnail {
      width: 100%;
      aspect-ratio: 16/9;
      background: linear-gradient(135deg, #16213e 0%, #1a1a2e 50%, #0a0a1a 100%);
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 15px;
      position: relative;
      overflow: hidden;
      border: 1px solid rgba(33, 150, 243, 0.3);
    }

    .video-thumbnail-icon {
      font-size: 56px;
      opacity: 0.4;
      z-index: 1;
    }

    .video-thumbnail::before {
      content: '';
      position: absolute;
      inset: 0;
      background: radial-gradient(ellipse at center, rgba(33, 150, 243, 0.15) 0%, transparent 70%);
    }

    .video-thumbnail::after {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(to top, rgba(0, 0, 0, 0.85) 0%, transparent 60%);
    }

    .video-info {
      position: absolute;
      bottom: 10px;
      left: 10px;
      right: 10px;
      z-index: 1;
    }

    .video-info h3 {
      font-size: 14px;
      font-weight: 600;
      color: white;
      margin-bottom: 4px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .video-info p {
      font-size: 12px;
      color: #aaa;
    }

    /* Control Buttons */
    .control-buttons {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
      margin-bottom: 20px;
    }

    .control-btn {
      padding: 15px;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      font-size: 16px;
      font-weight: 500;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }

    .control-btn.play {
      background: linear-gradient(135deg, #4CAF50 0%, #388E3C 100%);
      color: white;
      grid-column: span 3;
    }

    .control-btn.pause {
      background: linear-gradient(135deg, #FF9800 0%, #F57C00 100%);
      color: white;
      grid-column: span 3;
    }

    .control-btn.speed {
      background: linear-gradient(135deg, #03A9F4 0%, #0288D1 100%);
      color: white;
      font-weight: bold;
      font-size: 18px;
    }

    .control-btn.skip {
      background: rgba(33, 150, 243, 0.2);
      color: #2196F3;
    }

    .control-btn:hover {
      transform: scale(1.02);
    }

    /* Seek Control */
    .seek-control {
      display: flex;
      gap: 10px;
    }

    .seek-control input {
      flex: 1;
      padding: 12px 15px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      background: rgba(255, 255, 255, 0.05);
      color: #e0e0e0;
      font-size: 14px;
    }

    .seek-control input:focus {
      outline: none;
      border-color: #2196F3;
      box-shadow: 0 0 10px rgba(33, 150, 243, 0.2);
    }

    /* Track Selection */
    .track-selection {
      margin-top: 20px;
      padding-top: 20px;
      border-top: 1px solid rgba(255, 255, 255, 0.1);
    }

    .track-group {
      display: flex;
      align-items: center;
      gap: 15px;
      margin-bottom: 12px;
    }

    .track-group label {
      min-width: 100px;
      font-size: 14px;
      color: #888;
    }

    .track-group select {
      flex: 1;
      padding: 10px 15px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      background: rgba(255, 255, 255, 0.05);
      color: #e0e0e0;
      font-size: 14px;
      cursor: pointer;
    }

    .track-group select:focus {
      outline: none;
      border-color: #2196F3;
    }

    /* Playlist in Remote */
    .remote-playlist {
      max-height: calc(100vh - 200px);
      overflow-y: auto;
    }

    /* BSL Modal */
    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0);
      z-index: 1000;
      justify-content: center;
      align-items: center;
      transition: background 0.3s ease-out;
    }

    .modal.visible {
      display: flex;
    }

    .modal.visible.animate {
      background: rgba(0, 0, 0, 0.8);
    }

    .modal-content {
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 16px;
      padding: 25px;
      max-width: 800px;
      max-height: 80vh;
      overflow-y: auto;
      width: 90%;
      opacity: 0;
      transform: translateY(30px);
      transition: opacity 0.3s ease-out, transform 0.3s ease-out;
    }

    .modal.visible.animate .modal-content {
      opacity: 1;
      transform: translateY(0);
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      padding-bottom: 15px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    .modal-header h2 {
      font-size: 20px;
      color: #fff;
    }

    .modal-close {
      background: rgba(244, 67, 54, 0.2);
      color: #f44336;
      border: none;
      padding: 8px 15px;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .modal-close:hover {
      background: rgba(244, 67, 54, 0.3);
    }

    /* Status Messages */
    .status-message {
      padding: 12px 20px;
      border-radius: 8px;
      margin-top: 15px;
      opacity: 0;
      transform: translateY(10px);
      transition: opacity 0.3s ease, transform 0.3s ease;
      pointer-events: none;
    }

    .status-message.visible {
      opacity: 1;
      transform: translateY(0);
      pointer-events: auto;
    }

    .status-success {
      background: rgba(76, 175, 80, 0.2);
      color: #4CAF50;
      border: 1px solid rgba(76, 175, 80, 0.3);
    }

    .status-error {
      background: rgba(244, 67, 54, 0.2);
      color: #f44336;
      border: 1px solid rgba(244, 67, 54, 0.3);
    }

    .status-info {
      background: rgba(33, 150, 243, 0.2);
      color: #2196F3;
      border: 1px solid rgba(33, 150, 243, 0.3);
    }

    .status-warning {
      background: rgba(255, 152, 0, 0.2);
      color: #FF9800;
      border: 1px solid rgba(255, 152, 0, 0.3);
    }

    /* Empty State */
    .empty-message {
      text-align: center;
      padding: 40px 20px;
      color: #666;
      font-style: italic;
    }

    /* Action Bar */
    .action-bar {
      display: flex;
      justify-content: center;
      gap: 15px;
      padding: 20px;
      margin-top: auto;
    }

    /* BSL Badge */
    .bsl-badge {
      display: inline-block;
      padding: 2px 6px;
      border-radius: 10px;
      font-size: 10px;
      margin-left: 8px;
    }

    .bsl-positive {
      background: rgba(76, 175, 80, 0.3);
      color: #4CAF50;
    }

    .bsl-negative {
      background: rgba(244, 67, 54, 0.3);
      color: #f44336;
    }

    .bsl-partial {
      background: rgba(255, 152, 0, 0.3);
      color: #FF9800;
    }

    /* BSL Client Cards */
    .bsl-client-card {
      background: rgba(255, 255, 255, 0.03);
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 15px;
    }

    .bsl-client-header {
      display: flex;
      justify-content: space-between;
      margin-bottom: 10px;
    }

    .bsl-file-list {
      max-height: 150px;
      overflow-y: auto;
      background: rgba(0, 0, 0, 0.2);
      padding: 10px;
      border-radius: 6px;
    }

    .bsl-file-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 6px 0;
      border-bottom: 1px solid rgba(255, 255, 255, 0.05);
    }

    .bsl-file-item:last-child {
      border-bottom: none;
    }

    .bsl-match-select {
      padding: 4px 8px;
      background: rgba(255, 255, 255, 0.05);
      color: #e0e0e0;
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 4px;
      font-size: 11px;
    }

    /* Loading Indicator */
    .loading-indicator {
      display: inline-block;
      width: 14px;
      height: 14px;
      border: 2px solid rgba(255, 255, 255, 0.2);
      border-top-color: #2196F3;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-left: 8px;
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }

    /* Scrollbar */
    ::-webkit-scrollbar {
      width: 6px;
    }

    ::-webkit-scrollbar-track {
      background: rgba(255, 255, 255, 0.05);
      border-radius: 3px;
    }

    ::-webkit-scrollbar-thumb {
      background: rgba(33, 150, 243, 0.5);
      border-radius: 3px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: rgba(33, 150, 243, 0.7);
    }

    /* HEVC Warning - Moved to Header */
    .hevc-warning {
      display: none;
      background: rgba(244, 67, 54, 0.2);
      border: 1px solid rgba(244, 67, 54, 0.3);
      color: #f44336;
      border-radius: 8px;
      text-align: center;
    }

    .hevc-warning.visible {
      display: flex;
      flex: 1;
      margin: 0;
      padding: 8px 16px;
      align-items: center;
      justify-content: center;
      animation: fadeIn 0.3s ease forwards;
    }

    .hevc-warning.fade-out {
      animation: fadeOut 0.3s ease forwards;
    }

    /* VPN/Proxy Warning */
    .vpn-warning {
      display: none;
      background: rgba(255, 152, 0, 0.2);
      border: 1px solid rgba(255, 152, 0, 0.3);
      color: #FF9800;
      border-radius: 8px;
    }

    .vpn-warning.visible {
      display: flex;
      flex: 1;
      margin: 0;
      padding: 8px 16px;
      align-items: center;
      justify-content: center;
      animation: fadeIn 0.3s ease forwards;
    }

    .vpn-warning.fade-out {
      animation: fadeOut 0.5s ease forwards;
    }

    @keyframes fadeOut {
      from {
        opacity: 1;
        transform: translateY(0);
      }

      to {
        opacity: 0;
        transform: translateY(-10px);
      }
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(-10px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    /* Hidden */
    .hidden {
      display: none !important;
    }

    /* YouTube Modal Styles */
    .youtube-input {
      width: 100%;
      padding: 12px 15px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      background: rgba(255, 255, 255, 0.05);
      color: #e0e0e0;
      font-size: 14px;
      margin-bottom: 15px;
    }

    .youtube-input:focus {
      outline: none;
      border-color: #f44336;
      box-shadow: 0 0 10px rgba(244, 67, 54, 0.2);
    }

    .youtube-preview {
      display: none;
      background: rgba(255, 255, 255, 0.03);
      border-radius: 8px;
      overflow: hidden;
      margin-bottom: 15px;
    }

    .youtube-preview.visible {
      display: block;
    }

    .youtube-preview img {
      width: 100%;
      aspect-ratio: 16/9;
      object-fit: cover;
    }

    .youtube-preview-info {
      padding: 12px 15px;
    }

    .youtube-preview-title {
      font-size: 14px;
      color: #fff;
      margin-bottom: 5px;
    }

    .youtube-preview-channel {
      font-size: 12px;
      color: #888;
    }

    .youtube-error {
      color: #f44336;
      font-size: 13px;
      padding: 10px;
      background: rgba(244, 67, 54, 0.1);
      border-radius: 6px;
      margin-bottom: 15px;
      display: none;
    }

    .youtube-error.visible {
      display: block;
    }

    /* Quick Controls - In Sidebar */
    .sidebar-spacer {
      flex: 1;
    }

    .quick-controls-bottom {
      margin-top: auto;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding-bottom: 10px;
    }

    .sidebar-divider {
      width: 100%;
      height: 1px;
      background: rgba(255, 255, 255, 0.1);
      margin: 10px 0;
    }

    .quick-btn {
      width: 45px;
      height: 45px;
      border: none;
      border-radius: 8px;
      font-size: 18px;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(255, 255, 255, 0.05);
      color: #e0e0e0;
      margin-bottom: 5px;
    }

    .quick-btn:hover {
      background: rgba(255, 255, 255, 0.15);
    }

    .quick-btn:active {
      transform: scale(0.95);
    }

    /* Auth Screen - shown before verification */
    #auth-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 9999;
    }

    #auth-screen.hidden {
      display: none;
    }

    .auth-content {
      text-align: center;
      color: white;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }

    .auth-spinner {
      width: 50px;
      height: 50px;
      border: 4px solid rgba(255, 255, 255, 0.1);
      border-top-color: #9C27B0;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin: 0 auto 20px;
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }

    .auth-denied {
      background: rgba(244, 67, 54, 0.1);
      border: 1px solid rgba(244, 67, 54, 0.3);
      border-radius: 16px;
      padding: 40px;
      max-width: 500px;
    }

    /* Hide main UI until authenticated */
    #admin-ui {
      display: none;
    }

    #admin-ui.authenticated {
      display: contents;
    }

    /* --- Mobile Responsive Enhancements --- */
    @media (max-width: 900px) {
      body {
        flex-direction: column;
      }

      .sidebar {
        width: 100%;
        height: auto;
        flex-direction: row;
        border-right: none;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        padding: 5px 15px;
        gap: 15px;
        position: sticky;
        top: 0;
        backdrop-filter: blur(15px);
        background: rgba(10, 10, 25, 0.9);
        z-index: 1000;
      }

      .sidebar-logo,
      .nav-indicator,
      .sidebar-spacer,
      .quick-controls-bottom,
      .nav-tooltip {
        display: none !important;
      }

      .nav-item {
        width: 45px;
        height: 45px;
        font-size: 20px;
        margin-bottom: 0;
      }

      .main-content {
        padding: 10px;
        height: auto;
        overflow: visible;
        flex: none;
      }

      .dashboard-grid {
        grid-template-columns: 1fr;
        gap: 15px;
      }

      .dashboard-main {
        flex-direction: column;
        gap: 15px;
      }

      .dashboard-main .panel {
        min-width: 0 !important;
      }

      .remote-layout {
        grid-template-columns: 1fr;
        display: flex;
        flex-direction: column;
        height: auto;
      }

      .remote-playlist-panel {
        max-height: 350px;
        overflow-y: auto;
        order: 2;
      }

      .remote-thumbnail-panel {
        order: 1;
      }

      .remote-controls-panel {
        order: 3;
      }

      .remote-bottom-panel {
        order: 4;
      }

      .media-playlist-layout {
        grid-template-columns: 1fr;
        gap: 15px;
      }

      .header {
        flex-direction: column;
        align-items: flex-start;
        gap: 10px;
        padding: 10px 5px;
      }

      .status-group {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        width: 100%;
      }

      .hevc-warning.visible,
      .vpn-warning.visible {
        margin: 5px 0;
        width: 100%;
        font-size: 12px;
      }

      .modal-content {
        width: 95% !important;
        padding: 15px !important;
        max-height: 90vh;
      }

      .panel {
        min-width: 0 !important;
        width: 100% !important;
      }

      .video-thumbnail {
        min-height: 180px;
      }

      .btn-sm {
        padding: 10px 16px;
        font-size: 14px;
      }

      .quick-btn {
        width: 50px;
        height: 50px;
      }

      .btn-move {
        padding: 8px 12px;
        font-size: 12px;
      }

      .panel {
        padding: 15px;
      }

      #logs-container {
        font-size: 13px !important;
        gap: 6px !important;
      }

      .sidebar,
      .modal-content,
      .file-list,
      #logs-container {
        overscroll-behavior: contain;
        -webkit-overflow-scrolling: touch;
      }
    }

    /* Landscape Mode - Compact layout for short viewports */
    @media (max-height: 550px) and (orientation: landscape) {
      body {
        flex-direction: row;
      }

      .sidebar {
        width: 60px;
        height: 100vh;
        flex-direction: column;
        position: fixed;
        left: 0;
        top: 0;
        border-bottom: none;
        border-right: 1px solid rgba(255, 255, 255, 0.1);
        padding: 10px 0;
      }

      .main-content {
        margin-left: 60px;
        padding: 5px 15px;
        height: auto;
        min-height: 100vh;
      }

      .header {
        padding: 5px 0;
        margin-bottom: 5px;
        flex-direction: row;
        align-items: center;
        justify-content: space-between;
      }

      .header h1 {
        font-size: 16px;
      }

      .dashboard-grid {
        grid-template-columns: repeat(3, 1fr);
        gap: 10px;
      }

      .dashboard-main {
        flex-wrap: wrap;
        gap: 10px;
      }

      .dashboard-main .panel {
        flex: 1 1 300px;
        min-width: 0 !important;
      }

      .stat-card {
        padding: 10px;
      }

      .stat-icon {
        width: 35px;
        height: 35px;
        font-size: 18px;
      }

      .stat-info h3 {
        font-size: 18px;
      }

      .remote-layout {
        display: flex;
        flex-direction: row;
        gap: 10px;
        height: auto;
        min-height: 0;
        overflow-x: auto;
        padding-bottom: 15px;
        /* Space for scrollbar */
      }

      .remote-playlist-panel {
        width: 250px;
        flex-shrink: 0;
        max-height: 70vh;
      }

      .remote-thumbnail-panel {
        flex: 1;
        min-width: 300px;
        max-height: 70vh;
      }

      .remote-controls-panel {
        width: 200px;
        flex-shrink: 0;
        max-height: 70vh;
      }

      .remote-bottom-panel {
        width: 100%;
        margin-top: 10px;
      }

      .video-thumbnail {
        height: 120px;
        aspect-ratio: auto;
        margin-bottom: 5px;
      }

      .video-thumbnail-icon {
        font-size: 32px;
      }

      .control-buttons {
        margin-bottom: 5px;
        gap: 5px;
        grid-template-columns: repeat(3, 1fr);
      }

      .control-btn {
        padding: 8px;
        font-size: 12px;
      }

      .view.active {
        animation: none;
      }
    }

    /* FFmpeg Tools Styles */
    .ffmpeg-section {
      background: rgba(255, 255, 255, 0.03);
      border-radius: 12px;
      padding: 20px;
      margin-bottom: 20px;
      border: 1px solid rgba(255, 255, 255, 0.05);
    }

    .ffmpeg-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      padding-bottom: 10px;
    }

    .ffmpeg-header h3 {
      font-size: 16px;
      color: #fff;
      display: flex;
      align-items: center;
      gap: 10px;
      margin: 0;
    }

    .ffmpeg-controls {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 15px;
      align-items: end;
    }

    .ffmpeg-btn {
      background: rgba(33, 150, 243, 0.2);
      border: 1px solid rgba(33, 150, 243, 0.3);
      color: #2196F3;
      padding: 8px 16px;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      font-weight: 500;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .ffmpeg-btn:hover {
      background: rgba(33, 150, 243, 0.3);
    }

    .ffmpeg-btn.danger {
      background: rgba(244, 67, 54, 0.2);
      border-color: rgba(244, 67, 54, 0.3);
      color: #f44336;
    }

    .ffmpeg-btn.danger:hover {
      background: rgba(244, 67, 54, 0.3);
    }

    .ffmpeg-warning {
      background: rgba(255, 152, 0, 0.15);
      border: 1px solid rgba(255, 152, 0, 0.3);
      color: #FF9800;
      padding: 10px 15px;
      border-radius: 6px;
      font-size: 13px;
      margin-bottom: 15px;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .job-queue {
      max-height: 200px;
      overflow-y: auto;
      background: rgba(0, 0, 0, 0.2);
      border-radius: 8px;
      padding: 10px;
    }

    .job-item {
      background: rgba(255, 255, 255, 0.05);
      border-radius: 6px;
      padding: 10px;
      margin-bottom: 8px;
      font-family: monospace;
      font-size: 12px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .job-progress {
      height: 4px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 2px;
      margin-top: 8px;
      position: relative;
      overflow: hidden;
    }

    .job-progress-bar {
      height: 100%;
      background: #2196F3;
      width: 0%;
      transition: width 0.3s ease;
    }

    .encoder-badge {
      display: inline-flex;
      align-items: center;
      gap: 5px;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 11px;
      background: rgba(255, 255, 255, 0.1);
      color: #aaa;
      margin-right: 5px;
    }

    .encoder-badge.active {
      background: rgba(76, 175, 80, 0.2);
      color: #4CAF50;
      border: 1px solid rgba(76, 175, 80, 0.3);
    }

    /* Password Modal Specifics */
    .password-input {
      width: 100%;
      background: rgba(0, 0, 0, 0.3);
      border: 1px solid rgba(255, 255, 255, 0.1);
      padding: 12px;
      border-radius: 8px;
      color: #fff;
      font-size: 16px;
      text-align: center;
      letter-spacing: 2px;
      margin-bottom: 20px;
    }
  </style>
</head>

<body>
  <!-- Auth Screen - Shown while verification is in progress -->
  <div id="auth-screen">
    <div class="auth-content" id="auth-content">
      <div class="auth-spinner"></div>
      <p>Verifying admin access...</p>
    </div>
  </div>

  <!-- Admin UI - Hidden until authenticated -->
  <div id="admin-ui">
    <!-- Sidebar Navigation -->
    <nav class="sidebar">
      <div class="sidebar-logo">S</div>

      <!-- Sliding active indicator -->
      <div class="nav-indicator" id="nav-indicator"></div>

      <div class="nav-item active" data-view="dashboard" onclick="switchView('dashboard')">
        üìä
        <span class="nav-tooltip">Dashboard</span>
      </div>

      <div class="nav-item" data-view="media" onclick="switchView('media')">
        üìÅ
        <span class="nav-tooltip">Media & Playlist</span>
      </div>

      <div class="nav-item" data-view="remote" onclick="switchView('remote')">
        üéÆ
        <span class="nav-tooltip">Remote Control</span>
      </div>

      <div class="nav-item" data-view="ffmpeg" onclick="switchView('ffmpeg')">
        üéûÔ∏è
        <span class="nav-tooltip">FFmpeg Tools</span>
      </div>

      <!-- Quick Controls - Bottom -->
      <div class="quick-controls-bottom">
        <button class="quick-btn" onclick="playVideo()" title="Play">‚ñ∂</button>
        <button class="quick-btn" onclick="pauseVideo()" title="Pause">‚è∏</button>
      </div>
    </nav>

    <!-- Main Content -->
    <main class="main-content">
      <!-- Header -->
      <header class="header glass">
        <h1>Sync-<span>Player</span> Admin</h1>
        <div class="status-group">
          <div id="hevc-warning" class="hevc-warning" style="font-size: 13px;">
            <strong>‚ö†Ô∏è HEVC Codec Warning:</strong>&nbsp;MKV files often use HEVC (H.265) codecs which may require HEVC
            extensions for browser playback. Consider using&nbsp;<a
              href="https://github.com/Lakunake/Minecraft-WebDisplays-Sync-Player/issues/35" target="_blank"
              style="color: #2196F3;">BSL-S¬≤ (Local Sync)</a>!
          </div>
          <div id="vpn-warning" class="vpn-warning" style="font-size: 13px;">
            <strong>‚ö†Ô∏è VPN/Proxy Detected:</strong>&nbsp;<span id="vpn-warning-list"></span> - May cause connection
            issues
            for clients.
          </div>
          <div class="connection-status glass">
            <div class="status-dot" id="connection-dot"></div>
            <span id="connection-text">Connecting...</span>
          </div>
        </div>
      </header>

      <!-- Dashboard View -->
      <div id="dashboard-view" class="view active">
        <div class="dashboard-grid">
          <div class="stat-card glass" style="cursor: pointer;" onclick="openClientsModal()">
            <div class="stat-icon blue">üë•</div>
            <div class="stat-info">
              <h3 id="client-count">0</h3>
              <p>Connected Clients</p>
            </div>
          </div>

          <div class="stat-card glass">
            <div class="stat-icon purple">üé¨</div>
            <div class="stat-info">
              <h3 id="playlist-count">0</h3>
              <p>Videos in Playlist</p>
            </div>
          </div>

          <div class="stat-card glass">
            <div class="stat-icon cyan">‚è±Ô∏è</div>
            <div class="stat-info">
              <h3 id="playback-status">Idle</h3>
              <p>Playback Status</p>
            </div>
          </div>
        </div>

        <div class="dashboard-main">
          <div class="panel glass-strong" style="flex: 1;">
            <div class="panel-header">
              <h2>Quick Actions</h2>
            </div>
            <div style="display: flex; gap: 15px; flex-wrap: wrap;">
              <button class="btn btn-primary" onclick="switchView('media')"
                style="padding: 18px 30px; font-size: 16px;">
                üìÅ Manage Playlist
              </button>
              <button class="btn btn-secondary" onclick="switchView('remote')"
                style="padding: 18px 30px; font-size: 16px;">
                üéÆ Remote Control
              </button>
              <button class="btn btn-secondary" id="dashboard-bsl-btn" style="padding: 18px 30px; font-size: 16px;">
                üîÑ BSL-S¬≤ Check
              </button>
              <button class="btn btn-secondary" onclick="window.open('/', '_blank')"
                style="padding: 18px 30px; font-size: 16px;">
                üì∫ Open Client View
              </button>
            </div>

            <div class="status-message" id="dashboard-status"></div>
          </div>

          <!-- Logs Panel -->
          <div class="panel glass-strong" style="min-width: 320px; flex: 1;">
            <div class="panel-header">
              <h2>üìã Logs</h2>
              <button class="btn btn-sm btn-secondary" onclick="clearLogs()">Clear</button>
            </div>
            <div id="logs-container"
              style="max-height: 570px; overflow-y: auto; display: flex; flex-direction: column; gap: 4px; font-size: 12px; font-family: monospace; padding-bottom: 10px;">
              <div class="log-entry" style="color: #888; opacity: 1;">Waiting for events...</div>
            </div>
          </div>

          <div class="panel glass-strong" style="min-width: 280px;">
            <div class="panel-header">
              <h2>‚öôÔ∏è Config</h2>
            </div>
            <div id="config-list"
              style="display: flex; flex-direction: column; gap: 8px; font-size: 13px; max-height: 400px; overflow-y: auto;">
              <div
                style="display: flex; justify-content: space-between; padding: 8px; background: rgba(255,255,255,0.03); border-radius: 6px;">
                <span style="color: #888;">Port</span>
                <span id="cfg-port">-</span>
              </div>
              <div
                style="display: flex; justify-content: space-between; padding: 8px; background: rgba(255,255,255,0.03); border-radius: 6px;">
                <span style="color: #888;">Skip Seconds</span>
                <span id="cfg-skip">-</span>
              </div>
              <div
                style="display: flex; justify-content: space-between; padding: 8px; background: rgba(255,255,255,0.03); border-radius: 6px;">
                <span style="color: #888;">Volume Step</span>
                <span id="cfg-volume">-</span>
              </div>
              <div
                style="display: flex; justify-content: space-between; padding: 8px; background: rgba(255,255,255,0.03); border-radius: 6px;">
                <span style="color: #888;">Max Volume</span>
                <span id="cfg-max-volume">-</span>
              </div>
              <div
                style="display: flex; justify-content: space-between; padding: 8px; background: rgba(255,255,255,0.03); border-radius: 6px;">
                <span style="color: #888;">Video Autoplay</span>
                <span id="cfg-autoplay">-</span>
              </div>
              <div
                style="display: flex; justify-content: space-between; padding: 8px; background: rgba(255,255,255,0.03); border-radius: 6px;">
                <span style="color: #888;">Join Mode</span>
                <span id="cfg-join-mode">-</span>
              </div>
              <div
                style="display: flex; justify-content: space-between; padding: 8px; background: rgba(255,255,255,0.03); border-radius: 6px;">
                <span style="color: #888;">HTTPS</span>
                <span id="cfg-https">-</span>
              </div>
              <div
                style="display: flex; justify-content: space-between; padding: 8px; background: rgba(255,255,255,0.03); border-radius: 6px;">
                <span style="color: #888;">Chat</span>
                <span id="cfg-chat">-</span>
              </div>
              <div
                style="display: flex; justify-content: space-between; padding: 8px; background: rgba(255,255,255,0.03); border-radius: 6px;">
                <span style="color: #888;">Server Mode</span>
                <span id="cfg-server-mode">-</span>
              </div>
              <div
                style="display: flex; justify-content: space-between; padding: 8px; background: rgba(255,255,255,0.03); border-radius: 6px;">
                <span style="color: #888;">Client Controls</span>
                <span id="cfg-client-controls">-</span>
              </div>
              <div
                style="display: flex; justify-content: space-between; padding: 8px; background: rgba(255,255,255,0.03); border-radius: 6px;">
                <span style="color: #888;">BSL-S¬≤ Mode</span>
                <span id="cfg-bsl-mode">-</span>
              </div>
              <div
                style="display: flex; justify-content: space-between; padding: 8px; background: rgba(255,255,255,0.03); border-radius: 6px;">
                <span style="color: #888;">BSL-S¬≤ Adv Match</span>
                <span id="cfg-bsl-adv">-</span>
              </div>
              <div
                style="display: flex; justify-content: space-between; padding: 8px; background: rgba(255,255,255,0.03); border-radius: 6px;">
                <span style="color: #888;">BSL-S¬≤ Threshold</span>
                <span id="cfg-bsl-threshold">-</span>
              </div>
              <div
                style="display: flex; justify-content: space-between; padding: 8px; background: rgba(255,255,255,0.03); border-radius: 6px;">
                <span style="color: #888;">Admin Lock</span>
                <span id="cfg-admin-lock">-</span>
              </div>
            </div>

            <!-- Server Mode Room Controls (hidden by default) -->
            <div id="server-mode-controls"
              style="display: none; margin-top: 15px; padding-top: 15px; border-top: 1px solid rgba(255,255,255,0.1);">
              <div
                style="display: flex; justify-content: space-between; padding: 8px; background: rgba(33,150,243,0.1); border-radius: 6px; margin-bottom: 10px;">
                <span style="color: #2196F3;">Room Code</span>
                <span id="room-code-display" style="font-family: monospace; font-weight: bold; color: #2196F3;">-</span>
              </div>
              <button class="btn btn-danger" onclick="deleteCurrentRoom()" style="width: 100%;">
                üóëÔ∏è Delete Room
              </button>
            </div>
          </div>
        </div>
      </div>

      <!-- Media & Playlist View -->
      <div id="media-view" class="view">


        <div class="media-playlist-layout">
          <!-- Available Files -->
          <div class="panel glass-strong">
            <div class="panel-header">
              <h2>üìÇ Available Files</h2>
              <button class="btn btn-sm btn-secondary" id="external-btn" onclick="openExternalModal()">üåê
                External</button>
            </div>
            <div class="file-list" id="file-browser">
              <div class="empty-message">Loading files...</div>
            </div>
          </div>

          <!-- Playlist -->
          <div class="panel glass-strong">
            <div class="panel-header">
              <h2>üìã Playlist</h2>
              <button class="btn btn-sm btn-secondary" id="bsl-check-btn">üîç BSL-S¬≤</button>
            </div>
            <div class="file-list" id="playlist-container">
              <div class="empty-message">No files in playlist yet</div>
            </div>
          </div>
        </div>

        <div class="panel glass" style="padding: 15px;">
          <div style="display: flex; align-items: center; gap: 20px;">
            <label style="font-size: 14px;">Main Video Start Time (seconds):</label>
            <input type="number" id="start-time" min="0" value="0"
              style="width: 100px; padding: 8px 12px; border: 1px solid rgba(255,255,255,0.1); border-radius: 6px; background: rgba(255,255,255,0.05); color: #e0e0e0;">
          </div>
        </div>

        <div class="action-bar">
          <button class="btn btn-primary" id="launch-btn" style="padding: 15px 40px; font-size: 16px;">
            üöÄ Launch Playlist
          </button>
        </div>
      </div>

      <!-- Remote Control View -->
      <div id="remote-view" class="view">
        <div class="remote-layout">
          <!-- Left: Playlist Sidebar -->
          <div class="panel glass-strong remote-playlist-panel">
            <div class="panel-header">
              <h2>üìã Playlist</h2>
            </div>
            <div class="file-list remote-playlist" id="remote-playlist-list">
              <div class="empty-message">No playlist active</div>
            </div>
          </div>

          <!-- Center: Large Thumbnail -->
          <div class="panel glass-strong remote-thumbnail-panel">
            <div class="video-thumbnail" style="flex: 1; margin-bottom: 0;">
              <span class="video-thumbnail-icon">üé¨</span>
              <div class="video-info">
                <h3 id="current-video-name">No video playing</h3>
                <p id="current-video-status">Waiting for playlist...</p>
              </div>
            </div>
          </div>

          <!-- Right: Control Buttons -->
          <div class="panel glass-strong remote-controls-panel">
            <div class="panel-header" style="margin-bottom: 10px;">
              <h2>üéÆ Controls</h2>
            </div>

            <button class="control-btn play" id="play-btn" style="width: 100%;">‚ñ∂ Play</button>
            <button class="control-btn pause" id="pause-btn" style="width: 100%;">‚è∏ Pause</button>

            <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px;">
              <button class="control-btn skip" id="skip-back-btn">‚Ü© <span id="skip-back-text">5s</span></button>
              <button class="control-btn skip" id="skip-media-btn" title="Skip to next/previous media">‚è≠ Skip</button>
              <button class="control-btn skip" id="skip-forward-btn"><span id="skip-forward-text">5s</span> ‚Ü™</button>
            </div>

            <button class="btn btn-secondary" id="skip-intro-btn"
              style="width: 100%; background: linear-gradient(135deg, #7B1FA2, #4A148C);">‚è© Skip
              Intro (<span id="skip-intro-text">90s</span>)</button>

            <div class="seek-control">
              <input type="number" id="seek-time" placeholder="Seconds" min="0" style="width: 80px;">
              <button class="btn btn-primary" id="seek-btn" style="flex: 1;">Seek</button>
            </div>

            <!-- Speed Control -->
            <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; position: relative;">
              <button class="control-btn speed" id="speed-down-btn">-</button>
              <div
                style="display: flex; flex-direction: column; align-items: center; justify-content: center; background: rgba(255,255,255,0.05); border-radius: 10px;">
                <div style="font-size: 11px; color: #888;">Speed</div>
                <div id="speed-display" style="font-weight: bold; color: #fff;">1.0x</div>
              </div>
              <button class="control-btn speed" id="speed-up-btn">+</button>

              <!-- Overlay Label -->
              <div
                style="position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; pointer-events: none;">
                <span
                  style="background: rgba(0,0,0,0.6); color: #ff9800; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; border-radius: 10px; font-size: 12px; font-weight: bold; border: 1px solid #ff9800;">Under
                  Construction</span>
              </div>
            </div>

            <button class="btn btn-secondary" id="get-time-btn" style="width: 100%;">‚è±Ô∏è Get Current
              Time</button>
            <div id="current-time-display"
              style="text-align: center; margin-top: 8px; font-size: 14px; color: #2196F3; font-family: monospace;">
            </div>
          </div>

          <!-- Bottom: Other Stuff (Track Selection, BSL, Relaunch) -->
          <div class="panel glass-strong remote-bottom-panel" style="padding: 15px;">
            <div style="display: flex; gap: 30px; align-items: center; flex-wrap: wrap;">
              <!-- Track Selection -->
              <div style="display: flex; align-items: center; gap: 10px;">
                <label style="color: #888; font-size: 13px;">Audio:</label>
                <select id="remote-audio-track" disabled
                  style="padding: 8px 12px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); border-radius: 6px; color: #e0e0e0; min-width: 150px;">
                  <option>No tracks available</option>
                </select>
              </div>

              <div style="display: flex; align-items: center; gap: 10px;">
                <label style="color: #888; font-size: 13px;">Subtitles:</label>
                <select id="remote-subtitle-track" disabled
                  style="padding: 8px 12px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); border-radius: 6px; color: #e0e0e0; min-width: 150px;">
                  <option>No tracks available</option>
                </select>
              </div>

              <!-- Status message bubble between track selection and buttons -->
              <div class="status-message" id="status-message" style="flex: 1; margin: 0; padding: 8px 16px;"></div>

              <div style="margin-left: auto; display: flex; gap: 10px;">
                <button class="btn btn-secondary" id="remote-bsl-btn">üîÑ BSL-S¬≤</button>
                <button class="btn btn-primary" id="relaunch-btn">üöÄ Relaunch</button>
              </div>
            </div>
          </div>
        </div>
      </div>
      <!-- FFmpeg Tools View -->
      <div id="ffmpeg-view" class="view">
        <h2 class="view-title">FFmpeg Tools</h2>

        <!-- Password Overlay -->
        <div id="ffmpeg-auth-overlay" class="glass" style="padding: 40px; text-align: center; margin-top: 20px;">
          <h3>üîê Design & Processing Tools</h3>
          <p style="color: #ccc; margin-bottom: 20px;">This section is protected. Please enter the password to access.
          </p>
          <input type="password" id="ffmpeg-password-input" class="password-input" placeholder="ACCESS PASSWORD"
            onkeypress="if(event.key === 'Enter') authenticateFfmpeg()">
          <button class="ffmpeg-btn" onclick="authenticateFfmpeg()"
            style="width: 100%; justify-content: center; padding: 12px; font-size: 14px; margin-top: 10px;">üîì Unlock
            Tools</button>
        </div>

        <!-- Main Content (Hidden until auth) -->
        <div id="ffmpeg-content" style="display: none;">

          <!-- Encoders Badge -->
          <div style="margin-bottom: 20px;">
            <span style="color: #888; font-size: 12px; margin-right: 10px;">DETECTED ENCODERS:</span>
            <div id="encoder-list" style="display: inline-block;">
              <span class="encoder-badge">Scanning...</span>
            </div>
          </div>

          <!-- Main Grid Layout -->
          <div style="display: grid; grid-template-columns: 2fr 1fr; gap: 20px; align-items: start;">

            <!-- Left Column: Tools -->
            <div style="display: flex; flex-direction: column; gap: 20px;">

              <!-- Remux Section -->
              <div class="ffmpeg-section" style="margin-bottom: 0;">
                <div class="ffmpeg-header">
                  <h3>üì¶ Remux (Fast, No Re-encode)</h3>
                </div>
                <div class="ffmpeg-controls">
                  <div>
                    <select id="remux-file-input" class="dropdown" style="width: 100%; margin-bottom: 10px;">
                      <option value="">Select source file...</option>
                    </select>
                    <div style="display: flex; gap: 10px;">
                      <select id="remux-preset" class="dropdown" style="flex: 1;">
                        <option value="mp4_fast">Clean Remux to MP4 (FastStart)</option>
                        <option value="mkv_copy">Remux to MKV (Copy Streams)</option>
                        <option value="header_fix">Fix Headers (Ignore Errors)</option>
                      </select>
                    </div>
                  </div>
                  <button class="ffmpeg-btn" onclick="runFfmpegPreset('remux')"
                    style="width: auto; min-width: 120px; justify-content: center;">‚ñ∂ Start Remux</button>
                </div>
              </div>

              <!-- Re-encode Section -->
              <div class="ffmpeg-section" style="margin-bottom: 0;">
                <div class="ffmpeg-header">
                  <h3>‚ö†Ô∏è Re-encode (CPU/GPU Intensive)</h3>
                </div>
                <!-- Warning moved inside standard flow or kept if preferred -->
                <div class="ffmpeg-warning" style="margin-bottom: 15px;">
                  ‚ö†Ô∏è <b>Warning:</b> This operation WILL put heavy load on the server.
                </div>
                <div class="ffmpeg-controls">
                  <div>
                    <select id="reencode-file-input" class="dropdown" style="width: 100%; margin-bottom: 10px;">
                      <option value="">Select source file...</option>
                    </select>
                    <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                      <select id="reencode-encoder" class="dropdown" style="flex: 1;">
                        <option value="auto">Auto-Detect Encoder</option>
                        <option value="libx264">CPU (x264)</option>
                        <!-- HW options injected by JS -->
                      </select>
                      <select id="reencode-quality" class="dropdown" style="flex: 1;">
                        <option value="high">High Quality</option>
                        <option value="medium" selected>Medium Quality</option>
                        <option value="low">Low Quality</option>
                      </select>
                    </div>
                    <select id="reencode-resolution" class="dropdown" style="width: 100%;">
                      <option value="original">Original Resolution</option>
                      <option value="1080">1080p</option>
                      <option value="720">720p</option>
                      <option value="480">480p</option>
                    </select>
                  </div>
                  <button class="ffmpeg-btn danger" onclick="runFfmpegPreset('reencode')"
                    style="width: auto; min-width: 120px; justify-content: center;">‚ñ∂ Start Re-encode</button>
                </div>
              </div>

              <!-- Extract Section -->
              <div class="ffmpeg-section" style="margin-bottom: 0;">
                <div class="ffmpeg-header">
                  <h3>üéµ Extract Tracks</h3>
                </div>
                <div class="ffmpeg-controls">
                  <div>
                    <select id="extract-file-input" class="dropdown" style="width: 100%; margin-bottom: 10px;">
                      <option value="">Select source file...</option>
                    </select>
                    <div style="display: flex; gap: 10px;">
                      <select id="extract-type" class="dropdown" style="flex: 1;">
                        <option value="audio">Audio Tracks</option>
                        <option value="subtitle">Subtitle Tracks</option>
                      </select>
                      <select id="extract-format" class="dropdown" style="flex: 1;">
                        <option value="aac">AAC (Audio)</option>
                        <option value="mp3">MP3 (Audio)</option>
                        <option value="webvtt">WebVTT (Subtitle)</option>
                        <option value="srt">SRT (Subtitle)</option>
                        <option value="ass">ASS (Subtitle)</option>
                      </select>
                    </div>
                  </div>
                  <button class="ffmpeg-btn" onclick="runFfmpegPreset('extract')"
                    style="width: auto; min-width: 120px; justify-content: center;">‚ñ∂ Extract</button>
                </div>
              </div>

            </div>

            <!-- Right Column: Queue -->
            <div class="ffmpeg-section"
              style="margin-bottom: 0; align-self: stretch; display: flex; flex-direction: column;">
              <div class="ffmpeg-header">
                <h3>üìã Job Queue</h3>
                <button class="text-btn" style="font-size: 12px;" onclick="refreshFfmpegJobs()">Refresh</button>
              </div>
              <div id="ffmpeg-queue" class="job-queue" style="flex: 1; max-height: none; min-height: 400px;">
                <div style="text-align: center; color: #888; padding: 20px;">No active jobs</div>
              </div>
            </div>

          </div>
        </div>
      </div>
    </main>

    <!-- BSL-S¬≤ Modal -->
    <div id="bsl-modal" class="modal">
      <div class="modal-content">
        <div class="modal-header">
          <h2>üîÑ BSL-S¬≤ Client Status</h2>
          <button class="modal-close" id="bsl-modal-close">‚úï Close</button>
        </div>
        <div id="bsl-modal-body">
          <div class="empty-message">Waiting for clients to select their local folders...</div>
        </div>
      </div>
    </div>

    <!-- Clients Modal -->
    <div id="clients-modal" class="modal">
      <div class="modal-content" style="max-width: 600px;">
        <div class="modal-header">
          <h2>üë• Connected Clients</h2>
          <button class="modal-close" id="clients-modal-close">‚úï Close</button>
        </div>
        <div id="clients-modal-body">
          <div class="empty-message">Loading clients...</div>
        </div>
      </div>
    </div>

    <!-- External Content Modal -->
    <div id="external-modal" class="modal">
      <div class="modal-content" style="max-width: 550px;">
        <div class="modal-header">
          <h2>üåê Add External Content</h2>
          <button class="modal-close" id="external-modal-close">‚úï Close</button>
        </div>
        <div id="external-modal-body">
          <input type="text" id="external-url-input" class="youtube-input" placeholder="Paste URL here...">
          <div id="external-error" class="youtube-error"></div>
          <div id="external-preview" class="youtube-preview">
            <img id="external-thumb" alt="Content thumbnail">
            <div class="youtube-preview-info">
              <p class="youtube-preview-title" id="external-title"></p>
              <p class="youtube-preview-channel" id="external-platform"></p>
            </div>
          </div>
          <button class="btn btn-primary" id="external-add-btn" style="width: 100%;" disabled>+ Add to Playlist</button>

          <div
            style="margin-top: 15px; padding: 12px; background: rgba(255,255,255,0.03); border-radius: 8px; font-size: 12px;">
            <p style="color: #888; margin-bottom: 8px;"><strong>Supported Platforms:</strong></p>
            <div style="display: flex; flex-wrap: wrap; gap: 6px;">
              <span class="badge badge-youtube">YouTube</span>
              <span class="badge badge-vimeo">Vimeo</span>
              <span class="badge badge-dailymotion">Dailymotion</span>
              <span class="badge badge-twitch">Twitch</span>
              <span class="badge badge-soundcloud">SoundCloud</span>
              <span class="badge badge-streamable">Streamable</span>
              <span class="badge badge-gdrive">Google Drive</span>
              <span class="badge badge-kick">Kick</span>
              <span class="badge badge-url">Direct URL</span>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div> <!-- Close admin-ui -->

  <script src="/socket.io/socket.io.js"></script>
  <script>
    const socket = io();
    let playlist = [];
    let mainVideoIndex = -1;
    let skipSeconds = 5;
    let skipIntroSeconds = 90;
    const thumbnailCache = {}; // Cache for loaded thumbnails

    // DOM Cache for performance
    const dom = {
      logs: null,
      playlist: null,
      fileBrowser: null,
      remotePlaylist: null,
      bslBody: null,
      connectionDot: null,
      connectionText: null,
      currentTime: null
    };

    function initDomCache() {
      dom.logs = document.getElementById('logs-container');
      dom.playlist = document.getElementById('playlist-container');
      dom.fileBrowser = document.getElementById('file-browser');
      dom.remotePlaylist = document.getElementById('remote-playlist-list');
      dom.bslBody = document.getElementById('bsl-modal-body');
      dom.connectionDot = document.getElementById('connection-dot');
      dom.connectionText = document.getElementById('connection-text');
      dom.currentTime = document.getElementById('current-time-display');
    }

    // Client-side escape utility
    function escapeHTML(text) {
      if (typeof text !== 'string') return '';
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // CSRF Token Management
    let csrfToken = window.CSRF_TOKEN || '';

    // Helper for authenticated fetch requests (includes CSRF token)
    async function authenticatedFetch(url, options = {}) {
      const headers = {
        ...options.headers,
        'X-CSRF-Token': csrfToken
      };

      const response = await fetch(url, { ...options, headers });

      // If token expired (403), try to refresh it
      if (response.status === 403) {
        try {
          const tokenRes = await fetch('/api/csrf-token');
          if (tokenRes.ok) {
            const data = await tokenRes.json();
            csrfToken = data.token;
            // Retry the request with new token
            headers['X-CSRF-Token'] = csrfToken;
            return fetch(url, { ...options, headers });
          }
        } catch (e) {
          console.error('Failed to refresh CSRF token:', e);
        }
      }

      return response;
    }

    // Refresh CSRF token periodically (every 12 hours)
    setInterval(async () => {
      try {
        const res = await fetch('/api/csrf-token');
        if (res.ok) {
          const data = await res.json();
          csrfToken = data.token;
        }
      } catch (e) {
        console.error('CSRF token refresh failed:', e);
      }
    }, 12 * 60 * 60 * 1000);

    document.addEventListener('DOMContentLoaded', initDomCache);

    // Throttle helper for high-frequency socket events
    function throttle(func, limit) {
      let inThrottle;
      return function () {
        const args = arguments;
        const context = this;
        if (!inThrottle) {
          func.apply(context, args);
          inThrottle = true;
          setTimeout(() => inThrottle = false, limit);
        }
      }
    }

    // Platform Themes (Colors & Icons)
    // Platform Themes (Colors & Icons)
    const PLATFORM_THEMES = {
      'youtube': { color: '#C62828', icon: 'üî¥', textColor: '#FFFFFF' }, // Red (Darker)
      'vimeo': { color: '#0277BD', icon: 'üîµ', textColor: '#FFFFFF' },   // Blue (Darker)
      'dailymotion': { color: '#1565C0', icon: '‚ö´', textColor: '#FFFFFF' }, // Dark Blue
      'twitch': { color: '#673AB7', icon: 'üíú', textColor: '#FFFFFF' },  // Purple (Darker)
      'soundcloud': { color: '#E65100', icon: 'üü†', textColor: '#FFFFFF' }, // Orange (Darker)
      'streamable': { color: '#0288D1', icon: 'üì∫', textColor: '#FFFFFF' }, // Light Blue (Darker)
      'gdrive': { color: '#2E7D32', icon: 'üìÅ', textColor: '#FFFFFF' },  // Green (Darker)
      'kick': { color: '#388E3C', icon: 'üü©', textColor: '#FFFFFF' },    // Forest Green (Instead of Neon)
      'directUrl': { color: '#455A64', icon: 'üîó', textColor: '#FFFFFF' }, // Blue Grey (Darker)
      'local': { color: '#1565C0', icon: 'üé¨', textColor: '#FFFFFF' },   // Default Blue (Darker)
      'audio': { color: '#EF6C00', icon: 'üéµ', textColor: '#FFFFFF' },   // Deep Orange
      'image': { color: '#2E7D32', icon: 'üñºÔ∏è', textColor: '#FFFFFF' }   // Green (Darker)
    };

    // Helper to get platform key from video object
    function getPlatformKey(video) {
      if (video.isYouTube) return 'youtube';

      // Check file extensions first
      const imageExtensions = ['.png', '.jpg', '.jpeg', '.webp', '.gif'];
      if (imageExtensions.some(ext => video.filename.toLowerCase().endsWith(ext))) return 'image';

      const audioExtensions = ['.mp3', '.flac', '.m4a', '.aac', '.ogg', '.wav'];
      if (audioExtensions.some(ext => video.filename.toLowerCase().endsWith(ext))) return 'audio';

      // Use platform property if available (from external content)
      if (video.platform) return video.platform;

      // Fallback based on badge/name if platform prop missing
      if (video.platformName) {
        const name = video.platformName.toLowerCase().replace(/\s/g, '');
        if (PLATFORM_THEMES[name]) return name;
        if (name.includes('google')) return 'gdrive';
        if (name.includes('url')) return 'directUrl';
      }

      return 'local';
    }

    // Apply platform theme to a thumbnail background element
    function applyPlatformTheme(element, video, isDark = false) {
      const key = getPlatformKey(video);
      const theme = PLATFORM_THEMES[key] || PLATFORM_THEMES['local'];

      // Set background color 
      element.style.backgroundColor = theme.color;
      if (isDark) {
        // Create a darker gradient
        element.style.backgroundImage = `linear-gradient(135deg, rgba(0,0,0,0.4), rgba(0,0,0,0.6)), linear-gradient(135deg, ${theme.color}aa, ${theme.color}44)`;
      } else {
        element.style.backgroundImage = `linear-gradient(135deg, ${theme.color}dd, ${theme.color}66)`;
      }

      // Add themed class for visibility
      element.classList.add('themed');

      // Return theme info
      return {
        icon: theme.icon,
        textColor: theme.textColor || '#FFFFFF',
        platformName: video.platformName || (key.charAt(0).toUpperCase() + key.slice(1))
      };
    }

    // Generate fingerprint for device identification (MUST match landing page!)
    function generateFingerprint() {
      const stored = localStorage.getItem('sync-player-fingerprint');
      if (stored) return stored;

      const fp = 'fp_' + Date.now().toString(36) + Math.random().toString(36).substr(2, 9);
      localStorage.setItem('sync-player-fingerprint', fp);
      return fp;
    }

    // Legacy admin fingerprint - for non-server mode
    function generateAdminFingerprint() {
      const components = [
        navigator.userAgent,
        navigator.language,
        navigator.platform,
        navigator.hardwareConcurrency || 'unknown',
        navigator.deviceMemory || 'unknown',
        screen.width + 'x' + screen.height,
        screen.colorDepth,
        new Date().getTimezoneOffset(),
        (() => {
          try {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            ctx.textBaseline = 'top';
            ctx.font = '14px Arial';
            ctx.fillText('Admin fingerprint', 2, 2);
            return canvas.toDataURL().slice(-50);
          } catch (e) {
            return 'no-canvas';
          }
        })()
      ];

      const str = components.join('|');

      // Generate a "full" 64-char deterministic hash from components
      // 1. FNV-1a hash the components string to get a seed
      let h = 0x811c9dc5;
      for (let i = 0; i < str.length; i++) {
        h ^= str.charCodeAt(i);
        h = Math.imul(h, 0x01000193);
      }

      // 2. Use the hash to seed a simple PRNG to generate a long stable fingerprint
      let s = h >>> 0;
      const nextRaw = () => {
        s = Math.imul(s ^ s >>> 7, 0x5F356375); // Xorshift-like mix
        s = Math.imul(s ^ s << 13, 0xB6718429);
        return (s >>> 0);
      };
      const nextHex = () => nextRaw().toString(16).padStart(8, '0');

      // Generate 8 32-bit blocks = 64 hex chars
      return 'admin-' + nextHex() + nextHex() + nextHex() + nextHex() +
        nextHex() + nextHex() + nextHex() + nextHex();
    }

    // Get or store admin fingerprint
    function getAdminFingerprint() {
      // For server mode rooms, use the same fingerprint as landing page
      const roomPathMatch = window.location.pathname.match(/^\/admin\/([A-Z0-9]{6})$/i);
      if (roomPathMatch) {
        // Server mode - use sync-player-fingerprint for consistency with landing page
        return generateFingerprint();
      }

      // Legacy mode - use admin-fingerprint
      let stored = localStorage.getItem('admin-fingerprint');
      if (stored) {
        return stored;
      }
      const fp = generateAdminFingerprint();
      localStorage.setItem('admin-fingerprint', fp);
      return fp;
    }

    const adminFingerprint = getAdminFingerprint();
    console.log('Admin fingerprint:', adminFingerprint);

    // Server mode room state
    let currentRoomCode = null;
    let currentRoomName = null;
    let isServerMode = false;

    // Check if we're in a room (server mode URL: /admin/:roomCode)
    const roomPathMatch = window.location.pathname.match(/^\/admin\/([A-Z0-9]{6})$/i);
    if (roomPathMatch) {
      currentRoomCode = roomPathMatch[1].toUpperCase();
      console.log('Room code from URL:', currentRoomCode);
    }

    // Config display
    socket.on('config', (cfg) => {
      if (cfg.port) document.getElementById('cfg-port').textContent = cfg.port;
      if (cfg.skipSeconds) document.getElementById('cfg-skip').textContent = cfg.skipSeconds + 's';
      if (cfg.volumeStep) document.getElementById('cfg-volume').textContent = Math.round(cfg.volumeStep * 100) + '%';
      document.getElementById('cfg-max-volume').textContent = (cfg.maxVolume || 100) + '%';
      document.getElementById('cfg-autoplay').textContent = cfg.videoAutoplay ? 'On' : 'Off';
      document.getElementById('cfg-join-mode').textContent = cfg.joinMode || 'sync';
      document.getElementById('cfg-https').textContent = cfg.useHttps ? 'On' : 'Off';
      document.getElementById('cfg-chat').textContent = cfg.chatEnabled !== false ? 'On' : 'Off';
      document.getElementById('cfg-server-mode').textContent = cfg.serverMode ? 'On' : 'Off';
      document.getElementById('cfg-client-controls').textContent = cfg.clientControlsDisabled ? 'Disabled' : 'Enabled';
      document.getElementById('cfg-bsl-mode').textContent = cfg.bslS2Mode || 'any';
      document.getElementById('cfg-bsl-adv').textContent = cfg.bslAdvancedMatch ? 'On' : 'Off';
      document.getElementById('cfg-bsl-threshold').textContent = cfg.bslAdvancedMatchThreshold || '1';
      document.getElementById('cfg-admin-lock').textContent = cfg.adminFingerprintLock ? 'On' : 'Off';
      skipSeconds = cfg.skipSeconds || 5;
      skipIntroSeconds = cfg.skipIntroSeconds || 90;
      document.getElementById('skip-intro-text').textContent = skipIntroSeconds + 's';

      // Server mode room info
      if (cfg.serverMode) {
        isServerMode = true;
        if (cfg.roomName) {
          currentRoomName = cfg.roomName;
          document.title = `Admin: ${cfg.roomName} - Sync-Player`;
        }
        // Show server mode room controls
        const serverModeControls = document.getElementById('server-mode-controls');
        if (serverModeControls && currentRoomCode) {
          serverModeControls.style.display = 'block';
          document.getElementById('room-code-display').textContent = currentRoomCode;
        }
      }
    });

    // Request config on load
    socket.on('connect', () => {
      // If we have a room code, join as admin
      if (currentRoomCode) {
        console.log('Joining room as admin:', currentRoomCode);
        socket.emit('join-room', {
          roomCode: currentRoomCode,
          name: 'Admin',
          fingerprint: adminFingerprint
        }, (response) => {
          if (response && response.success) {
            console.log('Joined room as admin:', response);
            currentRoomName = response.roomName;
            if (response.isAdmin) {
              // Server mode: Hide auth screen and show admin UI
              const authScreen = document.getElementById('auth-screen');
              const adminUI = document.getElementById('admin-ui');
              if (authScreen) authScreen.classList.add('hidden');
              if (adminUI) adminUI.classList.add('authenticated');
              console.log('Admin authenticated for room:', currentRoomCode);
            } else {
              alert('You are not the admin of this room. Redirecting...');
              window.location.href = `/watch/${currentRoomCode}`;
            }
          } else {
            console.error('Failed to join room:', response?.error);
            alert('Room not found or access denied');
            window.location.href = '/';
          }
        });
      } else {
        // Legacy mode - normal admin registration
        socket.emit('get-config');
      }
    });
    if (socket.connected) {
      if (currentRoomCode) {
        socket.emit('join-room', {
          roomCode: currentRoomCode,
          name: 'Admin',
          fingerprint: adminFingerprint
        });
      } else {
        socket.emit('get-config');
      }
    }

    // Handle room deleted (if another admin deleted it)
    socket.on('room-deleted', () => {
      alert('This room has been deleted.');
      window.location.href = '/';
    });

    // Delete room function (for server mode)
    function deleteCurrentRoom() {
      if (!currentRoomCode || !isServerMode) return;

      if (confirm('Are you sure you want to delete this room? All viewers will be disconnected.')) {
        socket.emit('delete-room', {
          roomCode: currentRoomCode,
          fingerprint: adminFingerprint
        }, (response) => {
          if (response && response.success) {
            window.location.href = '/';
          } else {
            alert('Failed to delete room: ' + (response?.error || 'Unknown error'));
          }
        });
      }
    }

    // Live server playlist and index for remote controls
    let serverPlaylist = null;
    let currentServerIndex = -1;

    // View order for nav indicator tracking
    const viewOrder = ['dashboard', 'media', 'remote', 'ffmpeg'];
    let currentViewName = 'dashboard';

    // View switching with scroll-like animation
    function switchView(viewName) {
      const oldIndex = viewOrder.indexOf(currentViewName);
      const newIndex = viewOrder.indexOf(viewName);
      const goingDown = newIndex > oldIndex;

      // Update nav active states
      document.querySelectorAll('.nav-item').forEach(n => n.classList.remove('active'));
      document.querySelectorAll('.view').forEach(v => {
        v.classList.remove('active', 'scroll-up', 'scroll-down');
      });

      const targetView = document.getElementById(`${viewName}-view`);

      // Apply direction class for animation
      if (goingDown) {
        targetView.classList.add('scroll-up'); // Content scrolls up (comes from bottom)
      } else {
        targetView.classList.add('scroll-down'); // Content scrolls down (comes from top)
      }

      targetView.classList.add('active');
      currentViewName = viewName;

      const activeNavItem = document.querySelector(`.nav-item[data-view="${viewName}"]`);
      activeNavItem.classList.add('active');

      // Move the indicator to the active nav item
      const indicator = document.getElementById('nav-indicator');
      if (indicator && activeNavItem) {
        const navTop = activeNavItem.offsetTop + (activeNavItem.offsetHeight / 2) - 15;
        indicator.style.top = navTop + 'px';
      }

      // Check HEVC warning visibility on tab switch
      updateHevcWarning();

      // Hide VPN warning on tab switch (media or remote)
      if (viewName !== 'dashboard') {
        const vpnWarning = document.getElementById('vpn-warning');
        if (vpnWarning && vpnWarning.classList.contains('visible')) {
          vpnWarning.classList.add('fade-out');
          setTimeout(() => {
            vpnWarning.classList.remove('visible', 'fade-out');
          }, 500);
        }
      }
    }

    // Initialize indicator position on load
    function initNavIndicator() {
      requestAnimationFrame(() => {
        const activeNavItem = document.querySelector('.nav-item.active');
        const indicator = document.getElementById('nav-indicator');
        if (indicator && activeNavItem) {
          // Disable transition for initial positioning
          indicator.style.transition = 'none';
          const navTop = activeNavItem.offsetTop + (activeNavItem.offsetHeight / 2) - 15;
          indicator.style.top = navTop + 'px';
          // Re-enable transition after a frame
          requestAnimationFrame(() => {
            indicator.style.transition = 'top 0.3s cubic-bezier(0.4, 0, 0.2, 1)';
          });
        }
      });
    }

    // Fetch available files from server
    async function loadFiles() {
      // Check for hydrated data from server (saves a round-trip)
      if (window.INITIAL_DATA && window.INITIAL_DATA.files) {
        displayFiles(window.INITIAL_DATA.files);
        // Also hydrate playlist if available
        if (window.INITIAL_DATA.playlist) {
          playlist = window.INITIAL_DATA.playlist;
          mainVideoIndex = window.INITIAL_DATA.currentVideoIndex ?? -1;
          updatePlaylistDisplay();
          updateDashboardStats();
        }
        // Important: clear it so we don't re-use stale data if we manually refresh parts
        // and delete it to save memory
        // delete window.INITIAL_DATA; 
        return;
      }

      try {
        const response = await fetch('/api/files');
        const files = await response.json();
        displayFiles(files);
      } catch (error) {
        console.error('Error loading files:', error);
        document.getElementById('file-browser').innerHTML =
          '<div class="empty-message">Error loading files. Check server connection.</div>';
      }
    }

    // Display files in the file browser
    function displayFiles(files) {
      const fileBrowser = dom.fileBrowser || document.getElementById('file-browser');

      // Also populate FFmpeg inputs
      const ffmpegInputs = ['remux-file-input', 'reencode-file-input', 'extract-file-input'];
      ffmpegInputs.forEach(id => {
        const select = document.getElementById(id);
        if (!select) return;

        // Preserve current selection if any
        const currentVal = select.value;

        // Reset options but keep the first prompt
        select.innerHTML = '<option value="">Select source file...</option>';

        files.forEach(file => {
          // Provide both MKV and MP4 options to all tools (let tool decide validation/appropriateness)
          if (file.filename.endsWith('.mkv') || file.filename.endsWith('.mp4') || file.filename.endsWith('.avi') || file.filename.endsWith('.mov')) {
            const opt = document.createElement('option');
            opt.value = file.filename;
            opt.textContent = file.filename;
            select.appendChild(opt);
          }
        });

        if (currentVal) select.value = currentVal;
      });

      if (files.length === 0) {
        fileBrowser.innerHTML = '<div class="empty-message">No media files found in videos folder</div>';
        return;
      }

      const fragment = document.createDocumentFragment();

      files.forEach((file) => {
        const fileItem = document.createElement('div');
        fileItem.className = 'file-item';

        const fileName = document.createElement('span');
        fileName.className = 'file-name';
        fileName.innerHTML = `<span class="file-icon">üé¨</span> ${file.escapedFilename || escapeHTML(file.filename)}`;

        if (file.filename.endsWith('.mkv')) {
          fileName.innerHTML += ' <span style="color: #FF9800;">‚ö†Ô∏è</span>';
        }

        const addBtn = document.createElement('button');
        addBtn.className = 'btn btn-sm btn-primary';
        addBtn.textContent = '+ Add';
        addBtn.onclick = () => addToPlaylist(file);

        fileItem.appendChild(fileName);
        fileItem.appendChild(addBtn);
        fragment.appendChild(fileItem);
      });

      fileBrowser.innerHTML = '';
      fileBrowser.appendChild(fragment);
    }

    // Add a file to the playlist
    async function addToPlaylist(file) {
      if (!playlist.some(item => item.filename === file.filename)) {
        const fileCopy = { ...file };

        if (fileCopy.filename.endsWith('.mkv') || fileCopy.filename.endsWith('.mp4')) {
          try {
            const response = await fetch(`/api/tracks/${encodeURIComponent(fileCopy.filename)}`);
            if (response.ok) {
              const tracks = await response.json();
              fileCopy.tracks = {
                audio: tracks.audio || [],
                subtitles: tracks.subtitles || []
              };
            } else {
              fileCopy.tracks = { audio: [], subtitles: [] };
            }
          } catch (error) {
            fileCopy.tracks = { audio: [], subtitles: [] };
          }
        } else {
          fileCopy.tracks = { audio: [], subtitles: [] };
        }

        if (fileCopy.filename.endsWith('.mkv')) {
          fileCopy.usesHEVC = true;
        }

        fileCopy.isNew = true; // Flag for slide-in animation
        playlist.push(fileCopy);
        updatePlaylistDisplay();
        updateHevcWarning();
        updateDashboardStats();
        // Clear the isNew flag after animation
        setTimeout(() => { fileCopy.isNew = false; }, 300);
      }
    }

    // Remove a file from the playlist
    function removeFromPlaylist(index) {
      const container = document.getElementById('playlist-container');
      const item = container.children[index];

      if (item) {
        // Add slide-out animation
        item.classList.add('slide-out');

        // Wait for animation then remove
        setTimeout(() => {
          playlist.splice(index, 1);
          if (mainVideoIndex === index) {
            mainVideoIndex = -1;
          } else if (mainVideoIndex > index) {
            mainVideoIndex--;
          }
          updatePlaylistDisplay();
          updateHevcWarning();
          updateDashboardStats();
        }, 400);
      } else {
        // Fallback if no element found
        playlist.splice(index, 1);
        if (mainVideoIndex === index) {
          mainVideoIndex = -1;
        } else if (mainVideoIndex > index) {
          mainVideoIndex--;
        }
        updatePlaylistDisplay();
        updateHevcWarning();
        updateDashboardStats();
      }
    }

    // Move playlist item
    function movePlaylistItem(index, direction) {
      const newIndex = index + direction;
      if (newIndex < 0 || newIndex >= playlist.length) return;

      [playlist[index], playlist[newIndex]] = [playlist[newIndex], playlist[index]];

      if (mainVideoIndex === index) {
        mainVideoIndex = newIndex;
      } else if (mainVideoIndex === newIndex) {
        mainVideoIndex = index;
      }

      updatePlaylistDisplay();
    }

    // Set as main video
    function setAsMain(index) {
      const container = document.getElementById('playlist-container');
      const items = container.querySelectorAll('.playlist-item');

      // Update classes on existing elements (enables CSS transitions)
      items.forEach((item, i) => {
        const thumbnailBg = item.querySelector('.thumbnail-bg');

        if (i === mainVideoIndex) {
          // Old main - remove main class and blur the thumbnail
          item.classList.remove('main');
          if (thumbnailBg) thumbnailBg.classList.remove('cleared');

          // Add back the Set Main button
          const existingBtn = item.querySelector('.btn-secondary');
          if (!existingBtn) {
            const setMainBtn = document.createElement('button');
            setMainBtn.className = 'btn btn-sm btn-secondary';
            setMainBtn.textContent = 'Set Main';
            setMainBtn.onclick = () => setAsMain(i);
            item.insertBefore(setMainBtn, item.querySelector('.btn-danger'));
          }

          // Remove Main badge
          const badge = item.querySelector('.badge-main');
          if (badge) badge.remove();
        }

        if (i === index) {
          // New main - add main class and clear the thumbnail blur
          item.classList.add('main');
          if (thumbnailBg) {
            requestAnimationFrame(() => {
              requestAnimationFrame(() => {
                thumbnailBg.classList.add('cleared');
              });
            });
          }

          // Remove Set Main button for this item
          const setMainBtn = item.querySelector('.btn-secondary');
          if (setMainBtn && setMainBtn.textContent === 'Set Main') {
            setMainBtn.remove();
          }

          // Add Main badge
          const badges = item.querySelector('.playlist-badges');
          if (badges && !badges.querySelector('.badge-main')) {
            const badge = document.createElement('span');
            badge.className = 'badge badge-main';
            badge.textContent = 'Main';
            badges.appendChild(badge);
          }
        }
      });

      mainVideoIndex = index;
    }

    // Update playlist display
    function updatePlaylistDisplay() {
      const container = dom.playlist || document.getElementById('playlist-container');
      if (!container) return;

      if (playlist.length === 0) {
        container.innerHTML = '<div class="empty-message">No files in playlist yet</div>';
        return;
      }

      const fragment = document.createDocumentFragment();

      playlist.forEach((item, index) => {
        const playlistItem = document.createElement('div');
        playlistItem.className = `playlist-item ${index === mainVideoIndex ? 'main' : ''} ${item.isNew ? 'slide-in' : ''}`;

        const thumbnailBg = document.createElement('div');
        thumbnailBg.className = 'thumbnail-bg';
        playlistItem.appendChild(thumbnailBg);

        const themeInfo = applyPlatformTheme(thumbnailBg, item);
        playlistItem.style.color = themeInfo.textColor;

        const isImage = ['.png', '.jpg', '.jpeg', '.webp', '.gif'].some(ext => item.filename.toLowerCase().endsWith(ext));

        if (isImage) {
          thumbnailBg.style.backgroundImage = `url('/media/${encodeURIComponent(item.filename)}')`;
          thumbnailBg.classList.add('cached', 'loaded');
          thumbnailBg.classList.remove('themed');
          playlistItem.style.color = '';
          if (index === mainVideoIndex) {
            requestAnimationFrame(() => requestAnimationFrame(() => thumbnailBg.classList.add('cleared')));
          }
        }
        else if (item.thumbnail && typeof item.thumbnail === 'string') {
          thumbnailBg.style.backgroundImage = `url('${item.thumbnail}')`;
          thumbnailBg.classList.add('cached', 'loaded');
          thumbnailBg.classList.remove('themed');
          playlistItem.style.color = '';
          if (index === mainVideoIndex) {
            requestAnimationFrame(() => requestAnimationFrame(() => thumbnailBg.classList.add('cleared')));
          }
        }
        else if (thumbnailCache[item.filename]) {
          thumbnailBg.style.backgroundImage = `url('${thumbnailCache[item.filename]}')`;
          thumbnailBg.classList.add('cached', 'loaded');
          thumbnailBg.classList.remove('themed');
          playlistItem.style.color = '';
          if (index === mainVideoIndex) {
            requestAnimationFrame(() => requestAnimationFrame(() => thumbnailBg.classList.add('cleared')));
          }
        } else if (!item.isYouTube && !item.isExternal) {
          fetch(`/api/thumbnail/${encodeURIComponent(item.filename)}`)
            .then(response => response.json())
            .then(data => {
              if (data.thumbnail) {
                thumbnailCache[item.filename] = data.thumbnail;
                thumbnailBg.style.backgroundImage = `url('${data.thumbnail}')`;
                thumbnailBg.classList.remove('themed');
                playlistItem.style.color = '';
                const img = new Image();
                img.onload = () => {
                  thumbnailBg.classList.add('loaded');
                  if (index === mainVideoIndex) thumbnailBg.classList.add('cleared');
                };
                img.src = data.thumbnail;
              }
            })
            .catch(() => { });
        }

        const number = document.createElement('span');
        number.className = 'playlist-number';
        number.textContent = index + 1;
        playlistItem.appendChild(number);

        const name = document.createElement('span');
        name.className = 'playlist-name';
        name.textContent = item.filename;
        name.title = item.filename;
        playlistItem.appendChild(name);

        const badges = document.createElement('div');
        badges.className = 'playlist-badges';

        if (item.isExternal || item.isYouTube) {
          const platformBadge = document.createElement('span');
          platformBadge.className = `badge ${item.badge || 'badge-youtube'}`;
          platformBadge.textContent = `${item.syncLevel === 'full' ? '' : item.syncLevel === 'limited' ? '‚ö†Ô∏è ' : 'üì∫ '}${item.platformName || 'YouTube'}`;
          badges.appendChild(platformBadge);
        }

        if (isImage) {
          const imgBadge = document.createElement('span');
          imgBadge.className = 'badge badge-image';
          imgBadge.textContent = 'Image';
          badges.appendChild(imgBadge);
        }

        const isAudio = ['.mp3', '.flac', '.m4a', '.aac', '.ogg', '.wav'].some(ext => item.filename.toLowerCase().endsWith(ext));
        if (isAudio) {
          const audioBadge = document.createElement('span');
          audioBadge.className = 'badge badge-audio';
          audioBadge.textContent = 'Audio';
          badges.appendChild(audioBadge);
        }

        if (index === mainVideoIndex) {
          const badge = document.createElement('span');
          badge.className = 'badge badge-main';
          badge.textContent = 'Main';
          badges.appendChild(badge);
        }
        playlistItem.appendChild(badges);

        const moveDiv = document.createElement('div');
        moveDiv.className = 'move-buttons';

        const upBtn = document.createElement('button');
        upBtn.className = 'btn-move';
        upBtn.textContent = '‚ñ≤';
        upBtn.disabled = index === 0;
        upBtn.onclick = (e) => { e.stopPropagation(); movePlaylistItem(index, -1); };
        moveDiv.appendChild(upBtn);

        const downBtn = document.createElement('button');
        downBtn.className = 'btn-move';
        downBtn.textContent = '‚ñº';
        downBtn.disabled = index === playlist.length - 1;
        downBtn.onclick = (e) => { e.stopPropagation(); movePlaylistItem(index, 1); };
        moveDiv.appendChild(downBtn);
        playlistItem.appendChild(moveDiv);

        if (index !== mainVideoIndex) {
          const setMainBtn = document.createElement('button');
          setMainBtn.className = 'btn btn-sm btn-secondary';
          setMainBtn.textContent = 'Set Main';
          setMainBtn.onclick = (e) => { e.stopPropagation(); setAsMain(index); };
          playlistItem.appendChild(setMainBtn);
        }

        const removeBtn = document.createElement('button');
        removeBtn.className = 'btn btn-sm btn-danger';
        removeBtn.textContent = '‚úï';
        removeBtn.onclick = (e) => { e.stopPropagation(); removeFromPlaylist(index); };
        playlistItem.appendChild(removeBtn);

        fragment.appendChild(playlistItem);
      });

      container.innerHTML = '';
      container.appendChild(fragment);
    }

    // Update HEVC warning
    function updateHevcWarning() {
      const hasMKV = playlist.some(item => item.filename.endsWith('.mkv'));
      const warning = document.getElementById('hevc-warning');

      // Only show if we have MKV files AND we are in the media view
      if (hasMKV && currentViewName === 'media') {
        if (!warning.classList.contains('visible')) {
          warning.classList.remove('fade-out');
          warning.classList.add('visible');
        }
      } else {
        if (warning.classList.contains('visible') && !warning.classList.contains('fade-out')) {
          warning.classList.add('fade-out');
          setTimeout(() => {
            // Check again if it should still be hidden (avoid race conditions)
            const stillNotNeeded = !playlist.some(item => item.filename.endsWith('.mkv')) || currentViewName !== 'media';
            if (stillNotNeeded && warning.classList.contains('fade-out')) {
              warning.classList.remove('visible', 'fade-out');
            }
          }, 300);
        }
      }
    }

    // Update dashboard stats
    function updateDashboardStats() {
      document.getElementById('playlist-count').textContent = playlist.length;
    }

    // Launch playlist
    function launchPlaylist() {
      if (playlist.length === 0) {
        showStatus('Playlist is empty!', 'error');
        return;
      }

      if (mainVideoIndex === -1) {
        mainVideoIndex = 0;
        updatePlaylistDisplay();
      }

      const startTime = document.getElementById('start-time').value || 0;

      const playlistWithTracks = playlist.map((item, index) => ({ ...item }));

      showStatus('Setting up playlist...', 'info');

      socket.emit('set-playlist', {
        playlist: playlistWithTracks,
        mainVideoIndex: parseInt(mainVideoIndex),
        startTime: parseFloat(startTime)
      });

      // Rename button to Relaunch after first launch
      document.getElementById('launch-btn').innerHTML = 'üîÑ Relaunch Playlist';
    }

    function showStatus(message, type) {
      const statusEl = document.getElementById('status-message');
      statusEl.textContent = message;
      statusEl.className = `status-message visible status-${type}`;
      // Keep inline flex styles
      statusEl.style.flex = '1';
      statusEl.style.margin = '0';
      statusEl.style.padding = '8px 16px';

      setTimeout(() => {
        statusEl.classList.remove('visible');
      }, 5000);
    }

    // Logging functions
    function addLog(message, type = 'info') {
      const container = dom.logs || document.getElementById('logs-container');
      if (!container) return;

      // Remove "Waiting for events..." message if present
      const waitingMsg = container.querySelector('.log-entry');
      if (waitingMsg && waitingMsg.textContent === 'Waiting for events...') {
        waitingMsg.remove();
      }

      const entry = document.createElement('div');
      entry.className = 'log-entry';

      const time = new Date().toLocaleTimeString('en-US', { hour12: false });
      const colors = {
        info: '#2196F3',
        success: '#4CAF50',
        warning: '#FF9800',
        error: '#f44336',
        client: '#9C27B0'
      };

      entry.style.color = colors[type] || '#e0e0e0';
      entry.innerHTML = `<span style="color:#666">[${time}]</span> ${message}`;

      container.appendChild(entry);

      // Batch scroll update with next frame
      requestAnimationFrame(() => {
        container.scrollTop = container.scrollHeight;
      });

      // Limit to 50 entries
      while (container.children.length > 50) {
        container.removeChild(container.firstChild);
      }
    }

    function clearLogs() {
      const container = document.getElementById('logs-container');
      if (container) {
        container.innerHTML = '<div class="log-entry" style="color: #888;">Logs cleared</div>';
      }
    }

    // Remote control functions
    function playVideo() {
      socket.emit('control', { action: 'playpause', state: true });
      document.getElementById('playback-status').textContent = 'Playing';
    }

    function pauseVideo() {
      socket.emit('control', { action: 'playpause', state: false });
      document.getElementById('playback-status').textContent = 'Paused';
    }

    function skipBack() {
      socket.emit('control', { action: 'skip', direction: 'back', seconds: skipSeconds });
    }

    function skipForward() {
      socket.emit('control', { action: 'skip', direction: 'forward', seconds: skipSeconds });
    }

    function seekTo() {
      const time = document.getElementById('seek-time').value;
      if (time) {
        socket.emit('control', { action: 'seek', time: parseFloat(time) });
      }
    }

    // Move playlist item in remote (sends to server)
    function movePlaylistItemRemote(index, direction) {
      const newIndex = index + direction;
      if (newIndex < 0 || newIndex >= serverPlaylist.videos.length) return;
      socket.emit('playlist-reorder', { fromIndex: index, toIndex: newIndex });
    }

    // Fetch and display video thumbnail
    // Fetch and display video thumbnail
    let currentThumbnailFilename = null;
    async function fetchThumbnail(filename) {
      const thumbnailEl = document.querySelector('.video-thumbnail');
      const thumbnailIcon = document.querySelector('.video-thumbnail-icon');

      if (!thumbnailEl) return;

      // Check cache first - if available, ALWAYS apply it (fixes bug where theme wipes it)
      if (thumbnailCache[filename]) {
        thumbnailEl.style.backgroundImage = `url('${thumbnailCache[filename]}')`;
        thumbnailEl.style.backgroundSize = 'cover';
        thumbnailEl.style.backgroundPosition = 'center';
        if (thumbnailIcon) thumbnailIcon.style.display = 'none';
        currentThumbnailFilename = filename;
        return;
      }

      // Avoid refetching same thumbnail if we don't have it cached yet
      if (currentThumbnailFilename === filename) return;
      currentThumbnailFilename = filename;

      try {
        const response = await fetch(`/api/thumbnail/${encodeURIComponent(filename)}`);
        if (response.ok) {
          const data = await response.json();
          if (data.thumbnail) {
            // Update cache
            thumbnailCache[filename] = data.thumbnail;

            thumbnailEl.style.backgroundImage = `url('${data.thumbnail}')`;
            thumbnailEl.style.backgroundSize = 'cover';
            thumbnailEl.style.backgroundPosition = 'center';
            if (thumbnailIcon) thumbnailIcon.style.display = 'none';
          }
        }
      } catch (error) {
        console.error('Error fetching thumbnail:', error);
        // Keep showing the icon on error
        if (thumbnailIcon) thumbnailIcon.style.display = '';
      }
    }

    // Render remote playlist sidebar
    function renderRemotePlaylistSidebar() {
      const container = dom.remotePlaylist || document.getElementById('remote-playlist-list');
      if (!container) return;

      if (!serverPlaylist || !serverPlaylist.videos || serverPlaylist.videos.length === 0) {
        container.innerHTML = '<div class="empty-message">No playlist active</div>';
        return;
      }

      const fragment = document.createDocumentFragment();

      serverPlaylist.videos.forEach((video, index) => {
        const item = document.createElement('div');
        item.className = 'playlist-item';
        item.style.cursor = 'pointer';
        if (index === currentServerIndex) item.classList.add('current');
        if (index === serverPlaylist.mainVideoIndex) item.classList.add('main');

        item.onclick = () => {
          socket.emit('playlist-jump', index);
          showStatus(`Jumping to video ${index + 1}...`, 'info');
        };

        const number = document.createElement('span');
        number.className = 'playlist-number';
        number.textContent = index + 1;
        item.appendChild(number);

        const name = document.createElement('span');
        name.className = 'playlist-name';
        name.title = video.filename;
        const nameText = document.createElement('span');
        nameText.textContent = video.filename + '          ' + video.filename;
        name.appendChild(nameText);
        item.appendChild(name);

        const badges = document.createElement('div');
        badges.className = 'playlist-badges';

        if (video.isExternal || video.isYouTube) {
          const platformBadge = document.createElement('span');
          platformBadge.className = `badge ${video.badge || 'badge-youtube'}`;
          const syncIcon = video.syncLevel === 'full' ? '‚úÖ' : video.syncLevel === 'limited' ? '‚ö†Ô∏è' : 'üì∫';
          platformBadge.textContent = `${syncIcon} ${video.platformName || 'YouTube'}`;
          badges.appendChild(platformBadge);
        }

        const thumbnailBg = document.createElement('div');
        thumbnailBg.className = 'thumbnail-bg';
        item.appendChild(thumbnailBg);

        const platformIcon = applyPlatformTheme(thumbnailBg, video);

        const iconFallback = document.createElement('div');
        iconFallback.className = 'thumbnail-icon-fallback';
        iconFallback.textContent = platformIcon;
        iconFallback.style.cssText = 'position:absolute; top:50%; left:50%; transform:translate(-50%, -50%); font-size:24px; z-index:1;';
        thumbnailBg.appendChild(iconFallback);

        const isImage = ['.png', '.jpg', '.jpeg', '.webp', '.gif'].some(ext => video.filename.toLowerCase().endsWith(ext));

        if (isImage) {
          thumbnailBg.style.backgroundImage = `url('/media/${encodeURIComponent(video.filename)}')`;
          thumbnailBg.classList.add('cached', 'loaded');
          thumbnailBg.classList.remove('themed');
          item.style.color = '';
        }
        else if (video.thumbnail && typeof video.thumbnail === 'string') {
          thumbnailBg.style.backgroundImage = `url('${video.thumbnail}')`;
          thumbnailBg.classList.add('cached', 'loaded');
          thumbnailBg.classList.remove('themed');
          item.style.color = '';
        }
        else if (thumbnailCache[video.filename]) {
          thumbnailBg.style.backgroundImage = `url('${thumbnailCache[video.filename]}')`;
          thumbnailBg.classList.add('cached', 'loaded');
          thumbnailBg.classList.remove('themed');
          item.style.color = '';
        }
        else if (!video.isYouTube && !video.isExternal) {
          fetch(`/api/thumbnail/${encodeURIComponent(video.filename)}`)
            .then(res => res.json())
            .then(data => {
              if (data.thumbnail && typeof data.thumbnail === 'string') {
                thumbnailCache[video.filename] = data.thumbnail;
                thumbnailBg.style.backgroundImage = `url('${data.thumbnail}')`;
                thumbnailBg.classList.add('loaded');
                thumbnailBg.classList.remove('themed');
                item.style.color = '';
              }
            })
            .catch(() => { });
        }

        if (isImage) {
          const imgBadge = document.createElement('span');
          imgBadge.className = 'badge badge-image';
          imgBadge.textContent = 'üñºÔ∏è Image';
          badges.appendChild(imgBadge);
        }

        const isAudio = ['.mp3', '.flac', '.m4a', '.aac', '.ogg', '.wav'].some(ext => video.filename.toLowerCase().endsWith(ext));
        if (isAudio) {
          const audioBadge = document.createElement('span');
          audioBadge.className = 'badge badge-audio';
          audioBadge.textContent = 'üéµ Audio';
          badges.appendChild(audioBadge);
        }

        if (index === serverPlaylist.mainVideoIndex) {
          const badge = document.createElement('span');
          badge.className = 'badge badge-main';
          badge.textContent = 'Main';
          badges.appendChild(badge);
        }
        if (index === currentServerIndex) {
          const badge = document.createElement('span');
          badge.className = 'badge badge-playing';
          badge.textContent = '‚ñ∂ Playing';
          badges.appendChild(badge);
        }
        item.appendChild(badges);

        const moveDiv = document.createElement('div');
        moveDiv.className = 'move-buttons';

        const upBtn = document.createElement('button');
        upBtn.className = 'btn-move';
        upBtn.textContent = '‚ñ≤';
        upBtn.disabled = index === 0;
        upBtn.onclick = (e) => { e.stopPropagation(); movePlaylistItemRemote(index, -1); };
        moveDiv.appendChild(upBtn);

        const downBtn = document.createElement('button');
        downBtn.className = 'btn-move';
        downBtn.textContent = '‚ñº';
        downBtn.disabled = index === serverPlaylist.videos.length - 1;
        downBtn.onclick = (e) => { e.stopPropagation(); movePlaylistItemRemote(index, 1); };
        moveDiv.appendChild(downBtn);
        item.appendChild(moveDiv);

        fragment.appendChild(item);
      });

      container.innerHTML = '';
      container.appendChild(fragment);
    }

    // Render remote track controls
    function renderRemoteTrackControls() {
      const audioSelect = document.getElementById('remote-audio-track');
      const subtitleSelect = document.getElementById('remote-subtitle-track');
      const thumbnailEl = document.querySelector('.video-thumbnail');
      const thumbnailIcon = document.querySelector('.video-thumbnail-icon');

      if (!serverPlaylist || !serverPlaylist.videos || serverPlaylist.videos.length === 0 || currentServerIndex < 0) {
        document.getElementById('current-video-name').textContent = 'No video playing';
        document.getElementById('current-video-status').textContent = 'Waiting for playlist...';
        audioSelect.innerHTML = '<option>No tracks available</option>';
        audioSelect.disabled = true;
        subtitleSelect.innerHTML = '<option>No tracks available</option>';
        subtitleSelect.disabled = true;
        // Reset thumbnail
        if (thumbnailEl) {
          thumbnailEl.style.backgroundImage = '';
          if (thumbnailIcon) {
            thumbnailIcon.style.display = 'none'; // Default hidden
            thumbnailIcon.textContent = '';
          }
        }
        return;
      }

      const videoInfo = serverPlaylist.videos[currentServerIndex];
      document.getElementById('current-video-name').textContent = videoInfo.filename;
      document.getElementById('current-video-status').textContent = `Video ${currentServerIndex + 1} of ${serverPlaylist.videos.length}`;

      // Apply platform theme
      const platformInfo = applyPlatformTheme(thumbnailEl, videoInfo);
      // Removed icon as per user request
      if (thumbnailIcon) {
        thumbnailIcon.style.display = 'none';
      }

      // Check if this is an image file
      const imageExtensions = ['.png', '.jpg', '.jpeg', '.webp', '.gif'];
      const isImage = imageExtensions.some(ext => videoInfo.filename.toLowerCase().endsWith(ext));

      if (isImage) {
        // Image files are their own thumbnails
        thumbnailEl.style.backgroundImage = `url('/media/${encodeURIComponent(videoInfo.filename)}')`;
        thumbnailEl.style.backgroundSize = 'cover';
        thumbnailEl.style.backgroundPosition = 'center';
        thumbnailEl.classList.remove('themed');
        if (thumbnailIcon) thumbnailIcon.style.display = 'none';
        currentThumbnailFilename = videoInfo.filename; // Prevent refetch
      }
      // Handle any video with a thumbnail (YouTube, Twitch, Vimeo, etc.)
      else if (videoInfo.thumbnail && typeof videoInfo.thumbnail === 'string') {
        thumbnailEl.style.backgroundImage = `url('${videoInfo.thumbnail}')`;
        thumbnailEl.style.backgroundSize = 'cover';
        thumbnailEl.style.backgroundPosition = 'center';
        thumbnailEl.classList.remove('themed');
        if (thumbnailIcon) thumbnailIcon.style.display = 'none';

        // Use a unique ID or filename for cache key
        const cacheKey = videoInfo.isYouTube ? videoInfo.youtubeId : videoInfo.filename;
        currentThumbnailFilename = cacheKey;
      } else if (!videoInfo.isExternal && !videoInfo.isYouTube) {
        // Local video - fetch thumbnail from server
        fetchThumbnail(videoInfo.filename);
      } else {
        // External content without valid thumbnail - use platform fallback
        applyPlatformTheme(thumbnailEl, videoInfo, true); // Use dark mode
        if (thumbnailIcon) {
          thumbnailIcon.textContent = platformInfo.platformName;
          thumbnailIcon.style.display = 'block';
          thumbnailIcon.style.fontSize = '24px';
          thumbnailIcon.style.fontWeight = 'bold';
        }
      }

      // Audio tracks
      const audioTracks = (videoInfo.tracks && videoInfo.tracks.audio) ? videoInfo.tracks.audio : [];
      audioSelect.innerHTML = '';
      if (audioTracks.length === 0) {
        audioSelect.innerHTML = '<option value="0">Default Audio</option>';
        audioSelect.disabled = true;
      } else {
        audioTracks.forEach((track, idx) => {
          const opt = document.createElement('option');
          // Use track.index (Stream ID) if available, common for FFmpeg/node-av tracks
          const trackId = (track.index !== undefined) ? track.index : idx;
          opt.value = trackId;
          opt.textContent = `${track.language} - ${track.title || 'Track ' + trackId}`;
          audioSelect.appendChild(opt);
        });
        audioSelect.disabled = false;
      }

      // Subtitle tracks
      const subtitleTracks = (videoInfo.tracks && videoInfo.tracks.subtitles) ? videoInfo.tracks.subtitles : [];
      subtitleSelect.innerHTML = '<option value="-1">None</option>';
      subtitleTracks.forEach((track, idx) => {
        const opt = document.createElement('option');
        const trackId = (track.index !== undefined) ? track.index : idx;
        opt.value = trackId;
        opt.textContent = `${track.language} - ${track.title || 'Track ' + trackId}`;
        subtitleSelect.appendChild(opt);
      });
      subtitleSelect.appendChild(document.createElement('option')).textContent = "---"; // Separator just in caseVisual
      subtitleSelect.disabled = false;
      subtitleSelect.disabled = false;

      // Set selected values
      if (videoInfo.selectedAudioTrack !== undefined) {
        audioSelect.value = videoInfo.selectedAudioTrack;
      }
      if (videoInfo.selectedSubtitleTrack !== undefined) {
        subtitleSelect.value = videoInfo.selectedSubtitleTrack;
      }
    }

    // Initialize
    document.addEventListener('DOMContentLoaded', () => {
      loadFiles();
      initNavIndicator();

      document.getElementById('launch-btn').addEventListener('click', launchPlaylist);
      document.getElementById('play-btn').addEventListener('click', playVideo);
      document.getElementById('pause-btn').addEventListener('click', pauseVideo);
      document.getElementById('skip-back-btn').addEventListener('click', skipBack);
      document.getElementById('skip-forward-btn').addEventListener('click', skipForward);
      document.getElementById('skip-media-btn').addEventListener('click', () => {
        socket.emit('skip-to-next-video');
        showStatus('Skipping to next media...', 'info');
      });
      document.getElementById('skip-intro-btn').addEventListener('click', () => {
        socket.emit('control', { action: 'skip', direction: 'forward', seconds: skipIntroSeconds });
        showStatus(`Skipping intro (${skipIntroSeconds}s)...`, 'info');
      });
      document.getElementById('seek-btn').addEventListener('click', seekTo);

      // Get current time button
      document.getElementById('get-time-btn').addEventListener('click', () => {
        socket.emit('request-sync');
      });

      // Relaunch button - relaunches the current playlist
      document.getElementById('relaunch-btn').addEventListener('click', () => {
        if (playlist.length === 0 && serverPlaylist && serverPlaylist.videos.length > 0) {
          // Use server playlist if local is empty
          socket.emit('set-playlist', {
            playlist: serverPlaylist.videos,
            mainVideoIndex: serverPlaylist.mainVideoIndex,
            startTime: 0
          });
          showStatus('Relaunching playlist...', 'info');
        } else if (playlist.length > 0) {
          // Use local playlist
          if (mainVideoIndex === -1) mainVideoIndex = 0;
          socket.emit('set-playlist', {
            playlist: playlist,
            mainVideoIndex: mainVideoIndex,
            startTime: 0
          });
          showStatus('Relaunching playlist...', 'info');
        }
      });

      // Track selection handlers
      document.getElementById('remote-audio-track').addEventListener('change', (e) => {
        socket.emit('track-change', {
          videoIndex: currentServerIndex,
          type: 'audio',
          trackIndex: parseInt(e.target.value)
        });
      });

      document.getElementById('remote-subtitle-track').addEventListener('change', (e) => {
        socket.emit('track-change', {
          videoIndex: currentServerIndex,
          type: 'subtitle',
          trackIndex: parseInt(e.target.value)
        });
      });

      // BSL buttons
      // Trigger new BSL check (prompts clients who haven't selected folder)
      const triggerBslCheck = () => {
        socket.emit('bsl-check-request');
        const modal = document.getElementById('bsl-modal');
        modal.classList.add('visible');
        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            modal.classList.add('animate');
          });
        });
        document.getElementById('bsl-modal-body').innerHTML =
          '<div class="empty-message">Waiting for clients to select their local folders...</div>';
      };

      // View stored BSL status (no new prompts)
      const viewBslStatus = () => {
        socket.emit('bsl-get-status');
        const modal = document.getElementById('bsl-modal');
        modal.classList.add('visible');
        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            modal.classList.add('animate');
          });
        });
      };

      document.getElementById('bsl-check-btn').addEventListener('click', triggerBslCheck);
      document.getElementById('dashboard-bsl-btn').addEventListener('click', triggerBslCheck);
      document.getElementById('remote-bsl-btn').addEventListener('click', viewBslStatus);
      document.getElementById('bsl-modal-close').addEventListener('click', () => {
        const modal = document.getElementById('bsl-modal');
        modal.classList.remove('animate');
        setTimeout(() => modal.classList.remove('visible'), 300);
      });

      // Clients modal close
      document.getElementById('clients-modal-close').addEventListener('click', () => {
        const modal = document.getElementById('clients-modal');
        modal.classList.remove('animate');
        setTimeout(() => modal.classList.remove('visible'), 300);
      });

      socket.emit('get-config');
    });

    // Open Clients Modal
    function openClientsModal() {
      const modal = document.getElementById('clients-modal');
      modal.classList.add('visible');
      // Trigger animation after display change
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          modal.classList.add('animate');
        });
      });
      document.getElementById('clients-modal-body').innerHTML = '<div class="empty-message">Loading clients...</div>';
      socket.emit('get-client-list');
    }

    // Render connected clients in modal
    function renderClientsModal(clients) {
      const body = document.getElementById('clients-modal-body');

      if (!clients || clients.length === 0) {
        body.innerHTML = '<div class="empty-message">No clients connected</div>';
        return;
      }

      let html = '';
      clients.forEach(client => {
        const safeDisplayName = escapeHTML(client.displayName || 'Unnamed');
        const safeSocketId = escapeHTML(client.socketId?.slice(-8) || '');
        const safeFingerprint = escapeHTML(client.fingerprint || 'Unknown');
        const safeDisplayValue = escapeHTML(client.displayName || '');
        const safeFingerprintData = escapeHTML(client.fingerprint || '');

        html += `
          <div class="bsl-client-card">
            <div class="bsl-client-header">
              <strong style="color: #2196F3;">${safeDisplayName}</strong>
            </div>
            <div style="display: flex; flex-direction: column; gap: 8px; font-size: 12px; font-family: monospace;">
              <div style="display: flex; justify-content: space-between;">
                <span style="color: #888;">Socket ID:</span>
                <span style="color: #9C27B0;">${safeSocketId}</span>
              </div>
              <div style="display: flex; justify-content: space-between;">
                <span style="color: #888;">Fingerprint:</span>
                <span style="color: #FF9800;">${safeFingerprint}</span>
              </div>
              <div style="display: flex; align-items: center; gap: 10px; margin-top: 8px;">
                <label style="color: #888;">Display Name:</label>
                <input type="text" value="${safeDisplayValue}" 
                  data-fingerprint="${safeFingerprintData}"
                  placeholder="Enter name..."
                  onchange="updateClientName(this)"
                  style="flex: 1; padding: 6px 10px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); border-radius: 4px; color: #e0e0e0; font-size: 12px;">
              </div>
            </div>
          </div>
        `;
      });

      body.innerHTML = html;
    }

    // Update client display name
    function updateClientName(inputEl) {
      const fingerprint = inputEl.dataset.fingerprint;
      const displayName = inputEl.value.trim();
      if (fingerprint) {
        socket.emit('set-client-display-name', { fingerprint, displayName });
        addLog(`Set client name: ${displayName}`, 'info');
      }
    }

    // Handle client list response
    socket.on('client-list', (clients) => {
      renderClientsModal(clients);
    });

    // Update remote control availability based on sync level
    function updateControlAvailability() {
      if (!serverPlaylist || !serverPlaylist.videos || currentServerIndex < 0) return;

      const video = serverPlaylist.videos[currentServerIndex];
      const syncLevel = video.syncLevel || 'full'; // Default to full for legacy/youtube/local

      const playBtn = document.getElementById('play-btn');
      const pauseBtn = document.getElementById('pause-btn');
      const skipBackBtn = document.getElementById('skip-back-btn');
      const skipForwardBtn = document.getElementById('skip-forward-btn');
      const seekBtn = document.getElementById('seek-btn');
      const seekInput = document.getElementById('seek-time');

      // Controls to manage
      const controls = [playBtn, pauseBtn, skipBackBtn, skipForwardBtn, seekBtn, seekInput];

      // Reset all to enabled
      controls.forEach(el => {
        if (el) {
          el.disabled = false;
          el.style.opacity = '1';
          el.style.cursor = 'pointer';
          el.title = '';
        }
      });

      if (syncLevel === 'limited') {
        // Limited: No seeking or skip seconds
        [seekBtn, seekInput, skipBackBtn, skipForwardBtn].forEach(el => {
          if (el) {
            el.disabled = true;
            el.style.opacity = '0.5';
            el.style.cursor = 'not-allowed';
            el.title = 'Not available for this platform';
          }
        });
      } else if (syncLevel === 'autoplay') {
        // Autoplay: No controls except playlist navigation
        controls.forEach(el => {
          if (el) {
            el.disabled = true;
            el.style.opacity = '0.5';
            el.style.cursor = 'not-allowed';
            el.title = 'Autoplay only - controls disabled';
          }
        });
      }
    }

    // Socket handlers
    socket.on('config', (config) => {
      skipSeconds = config.skipSeconds || 5;
      document.getElementById('skip-back-text').textContent = `${skipSeconds}s`;
      document.getElementById('skip-forward-text').textContent = `${skipSeconds}s`;
    });

    socket.on('playlist-update', (playlistObj) => {
      serverPlaylist = playlistObj;
      currentServerIndex = playlistObj.currentIndex;
      renderRemotePlaylistSidebar();
      renderRemoteTrackControls();
      updateControlAvailability();

      // Sync server playlist to media tab if we have videos
      if (playlistObj.videos && playlistObj.videos.length > 0) {
        playlist = [...playlistObj.videos];
        mainVideoIndex = playlistObj.mainVideoIndex >= 0 ? playlistObj.mainVideoIndex : 0;
        updatePlaylistDisplay();
        updateHevcWarning();
        updateDashboardStats();
        // Change Launch button to Relaunch since playlist is already active
        document.getElementById('launch-btn').innerHTML = 'üîÑ Relaunch Playlist';
      }
    });

    socket.on('playlist-position', (index) => {
      addLog(`Jumped to video ${index + 1}`, 'info');
      currentServerIndex = index;
      renderRemotePlaylistSidebar();
      renderRemoteTrackControls();
      updateControlAvailability();
    });

    socket.on('track-change', (data) => {
      if (!serverPlaylist || !serverPlaylist.videos) return;
      const vid = serverPlaylist.videos[data.videoIndex];
      if (!vid) return;
      if (data.type === 'audio') {
        vid.selectedAudioTrack = data.trackIndex;
      } else if (data.type === 'subtitle') {
        vid.selectedSubtitleTrack = data.trackIndex;
      }
      if (data.videoIndex === currentServerIndex) {
        renderRemoteTrackControls();
      }
    });

    // Client count update handler
    socket.on('client-count', (count) => {
      const prevCount = parseInt(document.getElementById('client-count').textContent) || 0;
      document.getElementById('client-count').textContent = count;
      if (count > prevCount) {
        addLog(`Client connected (total: ${count})`, 'client');
      } else if (count < prevCount) {
        addLog(`Client disconnected (total: ${count})`, 'warning');
      }
    });

    // Log playlist events
    socket.on('playlist-set', (data) => {
      if (data.success) {
        addLog('Playlist launched successfully', 'success');
        showStatus(data.message || 'Playlist launched!', 'success');
        document.getElementById('playback-status').textContent = 'Playing';
        setTimeout(() => switchView('remote'), 1500);
      } else {
        addLog('Failed to launch playlist: ' + (data.message || 'Unknown error'), 'error');
        showStatus(data.message || 'Failed to launch!', 'error');
      }
    });

    // Log sync events and update time display
    const throttledSyncHandler = throttle((state) => {
      if (state.isPlaying !== undefined) {
        addLog(`Playback: ${state.isPlaying ? 'Playing' : 'Paused'}`, 'info');
      }
      // Update time display
      if (state.currentTime !== undefined) {
        // Clamp to 0 to prevent negative values from rewind
        const totalSecs = Math.max(0, Math.floor(state.currentTime));
        const hours = Math.floor(totalSecs / 3600);
        const mins = Math.floor((totalSecs % 3600) / 60);
        const secs = totalSecs % 60;
        const timeStr = hours > 0
          ? `${hours}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`
          : `${mins}:${secs.toString().padStart(2, '0')}`;
        const displayEl = dom.currentTime || document.getElementById('current-time-display');
        if (displayEl) displayEl.textContent = `Current: ${timeStr} (${totalSecs}s)`;
      }
    }, 1000); // Only update UI once per second

    socket.on('sync', throttledSyncHandler);

    // Admin authentication handlers
    socket.on('connect', () => {
      // Update connection status UI
      const dot = document.getElementById('connection-dot');
      const text = document.getElementById('connection-text');
      if (dot && text) {
        dot.classList.remove('offline');
        text.textContent = 'Connected';
      }

      console.log('Connected to server, registering admin...');

      // Extract room code if in server mode URL
      const roomPathMatch = window.location.pathname.match(/^\/admin\/([A-Z0-9]{6})$/i);
      const roomCode = roomPathMatch ? roomPathMatch[1] : null;

      socket.emit('bsl-admin-register', {
        fingerprint: adminFingerprint,
        roomCode: roomCode
      });

      // Check for VPN/proxy software
      fetch('/api/vpn-check')
        .then(res => res.json())
        .then(data => {
          if (data.detected && data.detected.length > 0) {
            const vpnWarning = document.getElementById('vpn-warning');
            document.getElementById('vpn-warning-list').textContent = data.detected.join(', ');
            vpnWarning.classList.add('visible');
            addLog(`VPN/Proxy detected: ${data.detected.join(', ')}`, 'warning');

            // Auto-dismiss after 3 seconds
            setTimeout(() => {
              vpnWarning.classList.add('fade-out');
              setTimeout(() => {
                vpnWarning.classList.remove('visible', 'fade-out');
              }, 500); // Wait for fade animation
            }, 3000);
          }
        })
        .catch(err => console.log('VPN check skipped'));
    });

    socket.on('disconnect', () => {
      // Update connection status UI
      const dot = document.getElementById('connection-dot');
      const text = document.getElementById('connection-text');
      if (dot && text) {
        dot.classList.add('offline');
        text.textContent = 'Disconnected';
      }
    });

    socket.on('connect_error', () => {
      const dot = document.getElementById('connection-dot');
      const text = document.getElementById('connection-text');
      if (dot && text) {
        dot.classList.add('offline');
        text.textContent = 'Offline';
      }
    });

    if (socket.connected) {
      socket.emit('bsl-admin-register', { fingerprint: adminFingerprint });
    }

    // Speed Control Logic
    let currentSpeed = 1.0;
    const speedStep = 0.25;
    const minSpeed = 0.25;
    const maxSpeed = 3.0;

    function handleSpeed(change) {
      let newSpeed = currentSpeed + change;
      // Precision rounding
      newSpeed = Math.round(newSpeed * 100) / 100;

      if (newSpeed >= minSpeed && newSpeed <= maxSpeed) {
        currentSpeed = newSpeed;
        updateSpeedDisplay();

        // Send control event
        socket.emit('control', {
          action: 'rate',
          rate: currentSpeed
        });

        addLog(`Set speed to ${currentSpeed}x`, 'info');
      }
    }

    function updateSpeedDisplay() {
      const display = document.getElementById('speed-display');
      if (display) {
        display.textContent = currentSpeed + 'x';
      }
    }

    // Set initial listeners
    document.getElementById('speed-down-btn').addEventListener('click', () => handleSpeed(-speedStep));
    document.getElementById('speed-up-btn').addEventListener('click', () => handleSpeed(speedStep));

    // Handle sync event to update speed
    socket.on('sync', (state) => {
      if (state.playbackRate !== undefined && state.playbackRate !== currentSpeed) {
        currentSpeed = state.playbackRate;
        updateSpeedDisplay();
      }

      // Existing sync logic for time update
      if (state.currentTime !== undefined) {
        // Clamp to 0 to prevent negative values from rewind
        const totalSecs = Math.max(0, Math.floor(state.currentTime));
        const hours = Math.floor(totalSecs / 3600);
        const mins = Math.floor((totalSecs % 3600) / 60);
        const secs = totalSecs % 60;
        const timeStr = hours > 0
          ? `${hours}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`
          : `${mins}:${secs.toString().padStart(2, '0')}`;
        const displayEl = document.getElementById('current-time-display');
        if (displayEl) displayEl.textContent = `Current: ${timeStr} (${totalSecs}s)`;
      }
    });

    // Handle admin auth result
    socket.on('admin-auth-result', (result) => {
      const authScreen = document.getElementById('auth-screen');
      const authContent = document.getElementById('auth-content');
      const adminUI = document.getElementById('admin-ui');

      if (result.success) {
        // Hide auth screen and show admin UI
        authScreen.classList.add('hidden');
        adminUI.classList.add('authenticated');
        // Initialize nav indicator now that UI is visible
        initNavIndicator();
      } else {
        // Show access denied message in auth screen (escape the reason to prevent XSS)
        const safeReason = escapeHTML(result.reason || 'Access denied');
        authContent.innerHTML = `
          <div class="auth-denied">
            <div style="font-size: 48px; margin-bottom: 20px;">üîí</div>
            <h1 style="color: #f44336; margin-bottom: 15px;">Access Denied</h1>
            <p style="color: #ccc; margin-bottom: 20px;">${safeReason}</p>
            <p style="color: #888; font-size: 14px;">
              If you need to reset admin access, delete the file:<br>
              <code style="background: rgba(255,255,255,0.1); padding: 5px 10px; border-radius: 4px;">memory.json</code>
            </p>
          </div>
        `;
      }
    });

    let bslStatus = null;

    socket.on('bsl-check-started', (data) => {
      addLog(`BSL-S¬≤ check started (${data.clientCount} clients)`, 'info');
      if (data.clientCount === 0) {
        document.getElementById('bsl-modal-body').innerHTML =
          '<div class="empty-message">No clients connected yet.</div>';
      }
    });

    socket.on('bsl-status-update', (data) => {
      bslStatus = data;
      renderBslModal(data);
      // Log BSL status summary
      if (data.clients && data.clients.length > 0) {
        const totalMatches = data.clients.reduce((sum, c) => sum + Object.keys(c.matchedVideos).length, 0);
        addLog(`BSL-S¬≤ update: ${data.clients.length} clients, ${totalMatches} total matches`, 'success');
      }
    });

    function renderBslModal(data) {
      const modalBody = dom.bslBody || document.getElementById('bsl-modal-body');
      if (!modalBody) return;

      if (!data.clients || data.clients.length === 0) {
        modalBody.innerHTML = '<div class="empty-message">No clients have selected folders yet</div>';
        return;
      }

      let html = `<p style="color:#888;margin-bottom:15px;">Mode: <strong>${data.mode === 'all' ? 'All clients must have file' : 'Any client with file'}</strong></p>`;

      data.clients.forEach((client, clientIdx) => {
        const matchCount = Object.keys(client.matchedVideos).length;
        const displayName = escapeHTML(client.clientName || `Client ${clientIdx + 1}`);
        const safeClientId = escapeHTML(client.clientId || '');
        const fingerprintShort = escapeHTML((client.clientId || '').slice(-4));
        const safeSocketId = escapeHTML(client.socketId || '');
        const driftValues = client.driftValues || {};

        html += `
      <div class="bsl-client-card">
        <div class="bsl-client-header">
          <div style="display: flex; align-items: center; gap: 8px;">
            <input type="text" 
                   class="client-name-input" 
                   value="${displayName}" 
                   data-client-id="${safeClientId}"
                   title="Fingerprint: ${safeClientId}"
                   style="background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); 
                          border-radius: 4px; padding: 4px 8px; color: white; width: 150px; font-size: 13px;"
                   onchange="setClientName(this)"
                   onkeypress="if(event.key==='Enter') this.blur()">
            <span style="color: #666; font-size: 11px;">(${fingerprintShort})</span>
          </div>
          <span class="bsl-badge ${matchCount > 0 ? 'bsl-positive' : 'bsl-negative'}">
            ${matchCount}/${playlist.length} matched
          </span>
        </div>
        <div class="bsl-file-list">
    `;

        if (client.files.length === 0) {
          html += '<div class="empty-message">No video files found</div>';
        } else {
          client.files.forEach(file => {
            const safeFileName = escapeHTML(file.name || '');
            const matchedIdx = Object.entries(client.matchedVideos)
              .find(([idx, name]) => name === file.name)?.[0];

            const currentDrift = matchedIdx !== undefined ? (driftValues[matchedIdx] || 0) : 0;

            html += `
          <div class="bsl-file-item">
            <span style="flex: 1; overflow: hidden; text-overflow: ellipsis;">${safeFileName}</span>
            <div style="display: flex; align-items: center; gap: 8px;">
              ${matchedIdx !== undefined ? `
                <div style="display: flex; align-items: center; gap: 4px;" title="Drift: offset client playback time (¬±60s)">
                  <span style="color: #888; font-size: 10px;">Drift:</span>
                  <input type="number" 
                         class="bsl-drift-input"
                         value="${currentDrift}"
                         min="-60" max="60" step="1"
                         data-client-fingerprint="${safeClientId}"
                         data-playlist-index="${matchedIdx}"
                         onchange="handleDriftChange(this)"
                         style="width: 50px; padding: 2px 4px; background: rgba(255,255,255,0.05); 
                                border: 1px solid rgba(255,255,255,0.1); border-radius: 4px; 
                                color: #e0e0e0; font-size: 11px; text-align: center;">
                  <span style="color: #888; font-size: 10px;">s</span>
                </div>
              ` : ''}
              <select class="bsl-match-select" 
                      data-client-id="${safeSocketId}" 
                      data-file-name="${safeFileName}"
                      onchange="handleManualMatch(this)">
                <option value="-1" ${!matchedIdx ? 'selected' : ''}>Not matched</option>
                ${playlist.map((v, i) => `
                  <option value="${i}" ${matchedIdx == i ? 'selected' : ''}>${escapeHTML(v.filename)}</option>
                `).join('')}
              </select>
            </div>
          </div>
        `;
          });
        }

        html += '</div></div>';
      });

      modalBody.innerHTML = html;
    }

    function handleDriftChange(inputEl) {
      const clientFingerprint = inputEl.dataset.clientFingerprint;
      const playlistIndex = parseInt(inputEl.dataset.playlistIndex);
      const driftSeconds = parseInt(inputEl.value) || 0;

      socket.emit('bsl-set-drift', {
        clientFingerprint,
        playlistIndex,
        driftSeconds
      });
    }

    function handleManualMatch(selectEl) {
      const clientSocketId = selectEl.dataset.clientId;
      const clientFileName = selectEl.dataset.fileName;
      const playlistIndex = parseInt(selectEl.value);

      if (playlistIndex >= 0) {
        socket.emit('bsl-manual-match', {
          clientSocketId,
          clientFileName,
          playlistIndex
        });
      }
    }

    function setClientName(inputEl) {
      const clientId = inputEl.dataset.clientId;
      const displayName = inputEl.value.trim();
      if (clientId && displayName) {
        socket.emit('set-client-name', { clientId, displayName });
      }
    }

    window.handleManualMatch = handleManualMatch;
    window.setClientName = setClientName;

    // ==================== External Content Modal Functions ====================

    let currentExternalData = null;

    // Platform detection patterns
    const PLATFORM_PATTERNS = {
      youtube: {
        patterns: [
          /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/|youtube\.com\/v\/)([^&\n?#]+)/,
          /^([a-zA-Z0-9_-]{11})$/
        ],
        name: 'YouTube',
        badge: 'badge-youtube',
        syncLevel: 'full'
      },
      vimeo: {
        patterns: [/vimeo\.com\/(\d+)/],
        name: 'Vimeo',
        badge: 'badge-vimeo',
        syncLevel: 'full'
      },
      dailymotion: {
        patterns: [/dailymotion\.com\/video\/([a-zA-Z0-9]+)/],
        name: 'Dailymotion',
        badge: 'badge-dailymotion',
        syncLevel: 'full'
      },
      twitch: {
        patterns: [
          /clips\.twitch\.tv\/([a-zA-Z0-9_-]+)/,
          /twitch\.tv\/videos\/(\d+)/,
          /twitch\.tv\/([a-zA-Z0-9_]+)$/
        ],
        name: 'Twitch',
        badge: 'badge-twitch',
        syncLevel: 'limited'
      },
      soundcloud: {
        patterns: [/soundcloud\.com\/([^\/]+\/[^\/]+)/],
        name: 'SoundCloud',
        badge: 'badge-soundcloud',
        syncLevel: 'limited'
      },
      streamable: {
        patterns: [/streamable\.com\/([a-zA-Z0-9]+)/],
        name: 'Streamable',
        badge: 'badge-streamable',
        syncLevel: 'autoplay'
      },
      gdrive: {
        patterns: [/drive\.google\.com.*\/d\/([^\/]+)/],
        name: 'Google Drive',
        badge: 'badge-gdrive',
        syncLevel: 'autoplay'
      },
      kick: {
        patterns: [/kick\.com\/([a-zA-Z0-9_]+)/],
        name: 'Kick',
        badge: 'badge-kick',
        syncLevel: 'autoplay'
      },
      directUrl: {
        patterns: [/\.(mp4|webm|m3u8|ogg)(\?.*)?$/i],
        name: 'Direct URL',
        badge: 'badge-url',
        syncLevel: 'full'
      },
      rumble: {
        patterns: [
          /rumble\.com\/embed\/([a-zA-Z0-9]+)/,
          /rumble\.com\/([a-zA-Z0-9-]+)\.html/
        ],
        name: 'Rumble',
        badge: 'badge-rumble',
        syncLevel: 'autoplay'
      }
    };

    // Detect platform from URL
    function detectPlatform(url) {
      for (const [platform, config] of Object.entries(PLATFORM_PATTERNS)) {
        for (const pattern of config.patterns) {
          const match = url.match(pattern);
          if (match) {
            return { platform, id: match[1], config };
          }
        }
      }
      return null;
    }

    // Fetch content info via oEmbed or other methods
    async function fetchExternalInfo(platform, id, url) {
      let oembedUrl = null;
      let thumbnail = null;
      let title = 'External Content';
      let author = platform;

      try {
        switch (platform) {
          case 'youtube':
            oembedUrl = `https://www.youtube.com/oembed?url=${encodeURIComponent(`https://www.youtube.com/watch?v=${id}`)}&format=json`;
            thumbnail = `https://img.youtube.com/vi/${id}/hqdefault.jpg`;
            break;
          case 'vimeo':
            oembedUrl = `https://vimeo.com/api/oembed.json?url=${encodeURIComponent(`https://vimeo.com/${id}`)}`;
            break;
          case 'dailymotion':
            oembedUrl = `https://www.dailymotion.com/services/oembed?url=${encodeURIComponent(`https://www.dailymotion.com/video/${id}`)}&format=json`;
            break;
          case 'soundcloud':
            oembedUrl = `https://soundcloud.com/oembed?url=${encodeURIComponent(url)}&format=json`;
            break;
          case 'streamable':
            oembedUrl = `https://api.streamable.com/oembed.json?url=${encodeURIComponent(`https://streamable.com/${id}`)}`;
            break;
          case 'twitch':
            title = `Twitch: ${id}`;
            thumbnail = `https://static-cdn.jtvnw.net/previews-ttv/live_user_${id}-320x180.jpg`;
            return { title, author: 'Twitch', thumbnail };
          case 'gdrive':
            title = `Google Drive Video`;
            thumbnail = `https://drive.google.com/thumbnail?id=${id}&sz=w320`;
            return { title, author: 'Google Drive', thumbnail };
          case 'kick':
            title = `Kick: ${id}`;
            return { title, author: 'Kick', thumbnail: null };
          case 'directUrl':
            title = url.split('/').pop().split('?')[0] || 'Video';
            return { title, author: 'Direct URL', thumbnail: null };
          case 'rumble':
            oembedUrl = `https://rumble.com/api/Media/oembed.json?url=${encodeURIComponent(url)}`;
            break;
        }

        if (oembedUrl) {
          const response = await fetch(oembedUrl);
          if (response.ok) {
            const data = await response.json();
            title = data.title || title;
            author = data.author_name || data.provider_name || author;
            thumbnail = data.thumbnail_url || thumbnail;

            // For Rumble, we need to extract the REAL embed ID from the html field if possible
            // The public ID in the URL often differs from the embed ID
            if (platform === 'rumble' && data.html) {
              const embedMatch = data.html.match(/src="https:\/\/rumble\.com\/embed\/([a-zA-Z0-9]+)\/?"/);
              if (embedMatch && embedMatch[1]) {
                // Return the extracted embed ID as the 'id' effectively overriding the regex one
                return { title, author, thumbnail, id: embedMatch[1] };
              }
            }
          }
        }
      } catch (error) {
        console.log('Could not fetch oEmbed:', error);
      }

      return { title, author, thumbnail };
    }

    // Open External modal
    function openExternalModal() {
      const modal = document.getElementById('external-modal');
      modal.classList.add('visible');
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          modal.classList.add('animate');
        });
      });

      // Reset modal state
      document.getElementById('external-url-input').value = '';
      document.getElementById('external-preview').classList.remove('visible');
      document.getElementById('external-error').classList.remove('visible');
      document.getElementById('external-add-btn').disabled = true;
      currentExternalData = null;

      setTimeout(() => document.getElementById('external-url-input').focus(), 100);
    }

    // Close External modal
    function closeExternalModal() {
      const modal = document.getElementById('external-modal');
      modal.classList.remove('animate');
      setTimeout(() => modal.classList.remove('visible'), 300);
    }

    // Handle URL input
    async function handleExternalUrlInput(url) {
      const preview = document.getElementById('external-preview');
      const errorDiv = document.getElementById('external-error');
      const addBtn = document.getElementById('external-add-btn');

      preview.classList.remove('visible');
      errorDiv.classList.remove('visible');
      addBtn.disabled = true;
      currentExternalData = null;

      if (!url.trim()) return;

      const detected = detectPlatform(url.trim());
      if (!detected) {
        errorDiv.textContent = 'Unsupported URL. See supported platforms below.';
        errorDiv.classList.add('visible');
        return;
      }

      try {
        const info = await fetchExternalInfo(detected.platform, detected.id, url.trim());
        currentExternalData = {
          platform: detected.platform,
          platformName: detected.config.name,
          id: detected.id,
          url: url.trim(),
          syncLevel: detected.config.syncLevel,
          badge: detected.config.badge,
          ...info
        };

        // If fetchExternalInfo returned a specific ID (like for Rumble), use it
        if (info.id) {
          currentExternalData.id = info.id;
        }

        // Update preview
        const thumbEl = document.getElementById('external-thumb');
        if (info.thumbnail) {
          thumbEl.src = info.thumbnail;
          thumbEl.style.display = '';
        } else {
          thumbEl.style.display = 'none';
        }
        document.getElementById('external-title').textContent = info.title;
        document.getElementById('external-platform').textContent = `${detected.config.name} ‚Ä¢ ${detected.config.syncLevel === 'full' ? '‚úÖ Full Sync' : detected.config.syncLevel === 'limited' ? '‚ö†Ô∏è Limited Sync' : 'üì∫ Autoplay Only'}`;
        preview.classList.add('visible');
        addBtn.disabled = false;
      } catch (error) {
        errorDiv.textContent = error.message;
        errorDiv.classList.add('visible');
      }
    }

    // Add external content to playlist
    function addExternalToPlaylist() {
      if (!currentExternalData) return;

      const entry = {
        filename: currentExternalData.title,
        isExternal: true,
        platform: currentExternalData.platform,
        platformName: currentExternalData.platformName,
        externalId: currentExternalData.id,
        externalUrl: currentExternalData.url,
        syncLevel: currentExternalData.syncLevel,
        badge: currentExternalData.badge,
        title: currentExternalData.title,
        thumbnail: currentExternalData.thumbnail,
        author: currentExternalData.author,
        // Keep backward compatibility with YouTube
        isYouTube: currentExternalData.platform === 'youtube',
        youtubeId: currentExternalData.platform === 'youtube' ? currentExternalData.id : null,
        tracks: { audio: [], subtitles: [] },
        isNew: true
      };

      // Check if already in playlist
      const isDuplicate = playlist.some(item =>
        item.isExternal && item.platform === entry.platform && item.externalId === entry.externalId
      );

      if (!isDuplicate) {
        playlist.push(entry);
        updatePlaylistDisplay();
        updateDashboardStats();
        setTimeout(() => { entry.isNew = false; }, 300);
        closeExternalModal();
        addLog(`${currentExternalData.platformName} content added: ${currentExternalData.title}`, 'success');
      } else {
        document.getElementById('external-error').textContent = 'This content is already in the playlist.';
        document.getElementById('external-error').classList.add('visible');
      }
    }

    // Initialize External modal event listeners
    document.addEventListener('DOMContentLoaded', () => {
      document.getElementById('external-modal-close').addEventListener('click', closeExternalModal);

      let externalInputTimeout;
      document.getElementById('external-url-input').addEventListener('input', (e) => {
        clearTimeout(externalInputTimeout);
        externalInputTimeout = setTimeout(() => handleExternalUrlInput(e.target.value), 500);
      });

      document.getElementById('external-url-input').addEventListener('paste', (e) => {
        setTimeout(() => handleExternalUrlInput(e.target.value), 50);
      });

      document.getElementById('external-add-btn').addEventListener('click', addExternalToPlaylist);
    });

    // ==========================================
    // FFmpeg Tools Logic
    // ==========================================

    let ffmpegAuthenticated = false;

    async function authenticateFfmpeg() {
      const passwordInput = document.getElementById('ffmpeg-password-input');
      const password = passwordInput.value;

      try {
        const response = await fetch('/api/ffmpeg/auth', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ password })
        });

        const data = await response.json();

        if (data.success) {
          ffmpegAuthenticated = true;
          document.getElementById('ffmpeg-auth-overlay').style.display = 'none';
          document.getElementById('ffmpeg-content').style.display = 'block';
          sessionStorage.setItem('ffmpeg_password', password);

          scanEncoders();
          refreshFfmpegJobs();
          // Auto-refresh jobs every 2 seconds
          if (window.ffmpegJobInterval) clearInterval(window.ffmpegJobInterval);
          window.ffmpegJobInterval = setInterval(refreshFfmpegJobs, 2000);
        } else {
          showToast('Invalid password', 3000, true);
          passwordInput.value = '';
          passwordInput.focus();
        }
      } catch (error) {
        console.error('Auth error:', error);
        showToast('Authentication failed', 3000, true);
      }
    }

    async function scanEncoders() {
      try {
        const response = await fetch('/api/ffmpeg/encoders');
        const data = await response.json();

        const badgeContainer = document.getElementById('encoder-list');
        badgeContainer.innerHTML = '';

        if (data.encoders && data.encoders.length > 0) {
          data.encoders.forEach(enc => {
            const span = document.createElement('span');
            span.className = 'encoder-badge active';
            span.textContent = enc.toUpperCase();
            badgeContainer.appendChild(span);

            // Add to dropdown if not exists (libx264/cpu are default)
            const dropdown = document.getElementById('reencode-encoder');
            // Check if option exists
            if (![...dropdown.options].some(o => o.value === enc)) {
              const opt = document.createElement('option');
              opt.value = enc;
              opt.textContent = enc.toUpperCase() + ' (Hardware)';
              dropdown.appendChild(opt);
            }
          });
        } else {
          badgeContainer.innerHTML = '<span class="encoder-badge">None found (CPU only)</span>';
        }

      } catch (e) {
        console.error('Scan encoders error:', e);
      }
    }

    // Refresh file lists for dropdowns
    function refreshFfmpegFileList() {
      const inputs = ['remux-file-input', 'reencode-file-input', 'extract-file-input'];
      inputs.forEach(id => {
        const select = document.getElementById(id);
        // Keep first option
        const first = select.options[0];
        select.innerHTML = '';
        select.appendChild(first);

        if (typeof playlist !== 'undefined' && playlist.length > 0) {
          playlist.forEach(file => {
            const opt = document.createElement('option');
            opt.value = file.filename;
            opt.textContent = file.filename;
            select.appendChild(opt);
          });
        }
      });
    }

    // Mock job queue refresh for now
    async function refreshFfmpegJobs() {
      try {
        const response = await fetch('/api/ffmpeg/jobs');
        const data = await response.json();
        const queue = document.getElementById('ffmpeg-queue');
        queue.innerHTML = '';

        if (data.jobs && data.jobs.length > 0) {
          data.jobs.forEach(job => {
            const div = document.createElement('div');
            div.className = 'job-card';
            // Simple styling for job card
            div.style.padding = '10px';
            div.style.backgroundColor = 'rgba(255,255,255,0.05)';
            div.style.borderRadius = '5px';
            div.style.marginBottom = '8px';
            div.style.borderLeft = `3px solid ${job.status === 'completed' ? '#00e676' : job.status === 'failed' ? '#ff1744' : job.status === 'running' ? '#2979ff' : '#888'}`;

            div.innerHTML = `
                  <div style="display:flex; justify-content:space-between; margin-bottom:5px;">
                     <span style="font-weight:bold; color:#fff;">${job.type.toUpperCase()} <small style="opacity:0.7">#${job.id}</small></span>
                     <span style="font-size:12px; opacity:0.8">${job.status.toUpperCase()}</span>
                  </div>
                  <div style="font-size:12px; color:#aaa; margin-bottom:5px;">
                     ${job.filename} <span style="opacity:0.5">(${job.preset || ''})</span>
                  </div>
                  ${job.error ? `<div style="color:#ff1744; font-size:11px;">Error: ${job.error}</div>` : ''}
                  ${job.status === 'running' ? `
                    <div style="background:rgba(255,255,255,0.1); height:4px; border-radius:2px; margin-top:5px; overflow:hidden;">
                       <div style="background:#2979ff; width:${job.progress}%; height:100%;"></div>
                    </div>` : ''}
                `;
            queue.appendChild(div);
          });
        } else {
          queue.innerHTML = '<div style="text-align: center; color: #888; padding: 20px;">No active jobs</div>';
        }
      } catch (e) {
        console.error("Job refresh error:", e);
      }
    }

    async function runFfmpegPreset(type) {
      let filename, preset, options = {};

      if (type === 'remux') {
        filename = document.getElementById('remux-file-input').value;
        preset = document.getElementById('remux-preset').value;
      } else if (type === 'reencode') {
        filename = document.getElementById('reencode-file-input').value;
        preset = document.getElementById('reencode-quality').value; // Using quality as simplified preset key for now
        options.encoder = document.getElementById('reencode-encoder').value;
        options.resolution = document.getElementById('reencode-resolution').value;
      } else if (type === 'extract') {
        filename = document.getElementById('extract-file-input').value;
        preset = document.getElementById('extract-format').value;
        options.trackType = document.getElementById('extract-type').value;
      }

      if (!filename) {
        showToast('Please select a file first', 2000, true);
        return;
      }

      const password = sessionStorage.getItem('ffmpeg_password');

      try {
        const response = await fetch('/api/ffmpeg/run-preset', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            password,
            type,
            filename,
            preset,
            options
          })
        });

        const data = await response.json();
        if (data.success) {
          showToast('Job started successfully!', 2000);
          refreshFfmpegJobs();
          startJobPolling();
        } else {
          showToast(data.error || 'Failed to start job', 3000, true);
        }
      } catch (e) {
        console.error(e);
        showToast('Request failed', 3000, true);
      }
    }

    let pollingInterval;
    function startJobPolling() {
      if (pollingInterval) clearInterval(pollingInterval);
      pollingInterval = setInterval(refreshFfmpegJobs, 2000);
    }

    // Auto-login check if session matches
    if (sessionStorage.getItem('ffmpeg_password')) {
      // Ideally verify, but for UX immediately try to show content if we trust session
      authenticateFfmpeg();
    }

    window.openExternalModal = openExternalModal;
  </script>
</body>

</html>