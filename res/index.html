<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Sync-Player</title>
  <style>
    html,
    body {
      margin: 0;
      padding: 0;
      background: black;
      height: 100%;
      overflow: hidden;
    }

    video {
      width: 100%;
      height: 100%;
      background: black;
      display: none;
    }

    #image-display {
      width: 100%;
      height: 100%;
      object-fit: contain;
      background: black;
      display: none;
    }

    /* YouTube Player Container */
    #youtube-container {
      width: 100%;
      height: 100%;
      display: none;
      position: absolute;
      top: 0;
      left: 0;
    }

    #youtube-container.visible {
      display: block;
    }

    .player-container {
      width: 100%;
      height: 100%;
      display: none;
      position: absolute;
      top: 0;
      left: 0;
      background: black;
      z-index: 5;
      /* Below overlays but above background */
    }

    .player-container.visible {
      display: block;
    }

    #iframe-container iframe {
      width: 100%;
      height: 100%;
      border: none;
    }

    #youtube-player {
      width: 100%;
      height: 100%;
    }

    /* Overlay to capture clicks on YouTube */
    #youtube-click-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 10;
      cursor: pointer;
    }

    /* Make iframe ignore mouse events - our overlay handles them */
    #youtube-container iframe {
      pointer-events: none;
    }

    /* NOTE: YouTube iframe content cannot be styled via CSS due to cross-origin policy.
       The controls=0 player param hides most UI, but some branding may still appear. */

    video::-webkit-media-controls,
    video::-moz-media-controls {
      display: none !important;
    }

    #status {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      background: rgba(0, 0, 0, 0.7);
      padding: 10px 15px;
      border-radius: 5px;
      font-family: Arial, sans-serif;
      font-size: 16px;
      z-index: 100;
      pointer-events: none;
      text-shadow: 1px 1px 2px black;
      opacity: 0;
      transition: opacity 0.3s;
    }

    #status.visible {
      opacity: 1;
    }

    #waiting-message {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: white;
      font-size: 24px;
      font-family: Arial, sans-serif;
      text-align: center;
      z-index: 90;
      background: rgba(0, 0, 0, 0.7);
      padding: 20px 40px;
      border-radius: 10px;
    }

    #preload-video {
      display: none;
    }

    #current-track-info {
      position: absolute;
      bottom: 10px;
      right: 10px;
      color: rgba(255, 255, 255, 0.7);
      background: rgba(0, 0, 0, 0.5);
      padding: 5px 10px;
      border-radius: 3px;
      font-family: Arial, sans-serif;
      font-size: 12px;
      z-index: 90;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s;
    }

    #current-track-info.visible {
      opacity: 1;
    }

    /* BSL-S¬≤ Styles */
    #bsl-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.9);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 200;
    }

    #bsl-overlay.visible {
      display: flex;
    }

    .bsl-prompt {
      background: #252525;
      border-radius: 10px;
      padding: 30px;
      text-align: center;
      max-width: 500px;
    }

    .bsl-prompt h2 {
      color: #9C27B0;
      margin-bottom: 15px;
    }

    .bsl-prompt p {
      color: #aaa;
      margin-bottom: 20px;
    }

    .bsl-btn {
      background: #9C27B0;
      color: white;
      border: none;
      padding: 12px 25px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 16px;
      transition: background 0.2s;
    }

    .bsl-btn:hover {
      background: #7B1FA2;
    }

    .bsl-result {
      margin-top: 15px;
      padding: 10px;
      border-radius: 6px;
    }

    .bsl-result.success {
      background: #2c5f2d;
    }

    .bsl-result.partial {
      background: #FF9800;
      color: #333;
    }

    .bsl-btn-skip {
      background: transparent;
      color: #888;
      border: 1px solid #555;
      padding: 8px 20px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      margin-left: 10px;
      transition: all 0.2s;
    }

    .bsl-btn-skip:hover {
      color: #fff;
      border-color: #888;
    }

    .bsl-buttons {
      display: flex;
      justify-content: center;
      gap: 10px;
    }

    #media-placeholder {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 5;
      /* Below overlays, above video background */
      color: white;
      font-family: sans-serif;
      background: #333;
      /* Default dark background */
    }

    #media-placeholder .icon {
      font-size: 100px;
      margin-bottom: 20px;
      filter: drop-shadow(0 0 10px rgba(0, 0, 0, 0.5));
    }

    #media-placeholder .text {
      font-size: 24px;
      text-shadow: 0 0 10px rgba(0, 0, 0, 0.8);
      padding: 10px 20px;
      background: rgba(0, 0, 0, 0.4);
      border-radius: 8px;
    }
  </style>
</head>

<body>
  <div id="media-placeholder">
    <div class="icon">üéµ</div>
    <div class="text">Audio Playing</div>
  </div>
  <video id="video" autoplay preload="auto"></video>
  <video id="preload-video" preload="auto"></video>
  <img id="image-display" alt="">

  <div id="youtube-container">
    <div id="youtube-player"></div>
    <div id="youtube-click-overlay"></div>
  </div>

  <!-- External Player Containers -->
  <div id="vimeo-container" class="player-container"></div>
  <div id="dailymotion-container" class="player-container"></div>
  <div id="twitch-container" class="player-container"></div>
  <div id="soundcloud-container" class="player-container"></div>
  <div id="iframe-container" class="player-container">
    <iframe id="generic-iframe" allow="autoplay; fullscreen" allowfullscreen></iframe>
  </div>

  <div id="waiting-message">Waiting for admin to launch playlist...</div>
  <div id="status"></div>
  <div id="current-track-info"></div>

  <!-- BSL-S¬≤ Folder Selection (hidden input + overlay) -->
  <input type="file" id="bsl-folder-input" webkitdirectory directory multiple hidden>
  <div id="bsl-overlay">
    <div class="bsl-prompt">
      <h2>üìÅ BSL-S¬≤ Local Sync</h2>
      <p>Admin is checking for local video files. Select your videos folder to enable local playback (saves bandwidth).
      </p>
      <div class="bsl-buttons">
        <button class="bsl-btn" id="bsl-select-btn">Select Videos Folder</button>
        <button class="bsl-btn" id="bsl-use-previous-btn"
          style="display: none; background: linear-gradient(135deg, #2196F3, #1976D2);">Use Previous Folder</button>
        <button class="bsl-btn-skip" id="bsl-skip-btn">Skip</button>
      </div>
      <div id="bsl-result" class="bsl-result" style="display:none;"></div>
    </div>
  </div>

  <!-- External Player SDKs -->
  <script src="https://player.vimeo.com/api/player.js"></script>
  <script src="https://player.twitch.tv/js/embed/v1.js"></script>
  <script src="https://api.dmcdn.net/all.js"></script>
  <script src="https://w.soundcloud.com/player/api.js"></script>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    const video = document.getElementById('video');
    const preloadVideo = document.getElementById('preload-video');
    const imageDisplay = document.getElementById('image-display');
    const waitingMessage = document.getElementById('waiting-message');
    const statusEl = document.getElementById('status');
    const currentTrackInfoEl = document.getElementById('current-track-info');
    const mediaPlaceholder = document.getElementById('media-placeholder');

    // Helper to check if a file is an image
    const imageExtensions = ['.png', '.jpg', '.jpeg', '.webp'];
    function isImageFile(filename) {
      const ext = filename.substring(filename.lastIndexOf('.')).toLowerCase();
      return imageExtensions.includes(ext);
    }

    // Helper to check if a file is audio
    const audioExtensions = ['.mp3', '.flac', '.m4a', '.aac', '.ogg', '.wav'];
    function isAudioFile(filename) {
      const ext = filename.substring(filename.lastIndexOf('.')).toLowerCase();
      return audioExtensions.includes(ext);
    }

    // Track if current media is an image
    let currentMediaIsImage = false;

    // YouTube Player state
    const youtubeContainer = document.getElementById('youtube-container');
    const youtubeClickOverlay = document.getElementById('youtube-click-overlay');
    let ytPlayer = null;
    let ytVideoHasPlayed = false;

    // External Player state
    let vimeoPlayer = null;
    let twitchPlayer = null;
    let dmPlayer = null;
    let scWidget = null;
    let currentPlatform = 'local'; // local, youtube, vimeo, twitch, etc.

    // Helper to hide all player containers
    function hideAllPlayers() {
      const containers = document.querySelectorAll('.player-container');
      containers.forEach(el => el.classList.remove('visible'));
      youtubeContainer.classList.remove('visible');
      video.style.display = 'none';
      imageDisplay.style.display = 'none';
      if (mediaPlaceholder) mediaPlaceholder.style.display = 'none';

      // Stop/Pause existing players if possible
      if (vimeoPlayer) vimeoPlayer.pause().catch(() => { });
      if (dmPlayer) dmPlayer.pause();
      if (twitchPlayer) {
        try {
          const player = twitchPlayer.getPlayer ? twitchPlayer.getPlayer() : twitchPlayer;
          if (player && player.pause) player.pause();
        } catch (e) { }
      }

      // Clear generic iframe source to stop playback
      const iframe = document.getElementById('generic-iframe');
      if (iframe) iframe.src = '';
    }

    // Generic handler for external video ending
    function handleVideoEnded() {
      console.log('External video ended');
      if (currentPlaylist.videos.length > 0) {
        const nextIndex = (currentPlaylist.currentIndex + 1) % currentPlaylist.videos.length;
        socket.emit('playlist-next', nextIndex);
      }
    }

    // Load external content (Vimeo, Twitch, etc.)
    function loadExternalContent(platform, id, url) {
      currentPlatform = platform;
      hideAllPlayers();

      if (platform === 'youtube') {
        youtubeContainer.classList.add('visible');
        currentMediaIsYouTube = true;
        // YouTube specific logic is handled by onYouTubeIframeAPIReady and socket play event
        // But we might need to trigger load if it's already ready
        if (ytPlayer && ytPlayerReady && id) {
          ytPlayer.loadVideoById(id);
        }
        return;
      }

      currentMediaIsYouTube = false;

      try {
        switch (platform) {
          case 'vimeo':
            document.getElementById('vimeo-container').classList.add('visible');
            if (!vimeoPlayer && window.Vimeo) {
              vimeoPlayer = new Vimeo.Player('vimeo-container', {
                id: id,
                autoplay: true,
                responsive: true,
                width: '100%',
                height: '100%'
              });
              vimeoPlayer.on('ended', handleVideoEnded);
            } else if (vimeoPlayer) {
              vimeoPlayer.loadVideo(id).then(() => vimeoPlayer.play()).catch(e => console.error('Vimeo play error:', e));
            }
            break;

          case 'twitch':
            document.getElementById('twitch-container').classList.add('visible');
            document.getElementById('twitch-container').innerHTML = ''; // Clear previous
            if (window.Twitch) {
              const twitchOptions = {
                width: '100%',
                height: '100%',
                layout: 'video',
                autoplay: true
              };
              // Determine if ID is channel or video
              if (id.match(/^\d+$/)) {
                twitchOptions.video = id;
              } else {
                twitchOptions.channel = id;
              }
              twitchPlayer = new Twitch.Embed('twitch-container', twitchOptions);
              twitchPlayer.addEventListener(Twitch.Embed.VIDEO_READY, () => {
                const player = twitchPlayer.getPlayer();
                if (player) {
                  player.addEventListener('ended', handleVideoEnded);
                }
              });
            }
            break;

          case 'dailymotion':
            document.getElementById('dailymotion-container').classList.add('visible');
            if (!dmPlayer && window.DM) {
              dmPlayer = DM.player(document.getElementById('dailymotion-container'), {
                video: id,
                width: '100%',
                height: '100%',
                params: { autoplay: true, mute: false, events: { video_end: handleVideoEnded } }
              });
              // DM API events usually bound via params for 'video_end' or addEventListener 'end'
              dmPlayer.addEventListener('end', handleVideoEnded);
            } else if (dmPlayer) {
              dmPlayer.load(id);
            }
            break;

          case 'soundcloud':
            document.getElementById('soundcloud-container').classList.add('visible');
            const scContainer = document.getElementById('soundcloud-container');
            scContainer.innerHTML = `<iframe id="sc-widget" width="100%" height="100%" scrolling="no" frameborder="no" allow="autoplay" src="https://w.soundcloud.com/player/?url=${encodeURIComponent(url)}&auto_play=true&visual=true"></iframe>`;
            if (window.SC) {
              const widget = SC.Widget('sc-widget');
              widget.bind(SC.Widget.Events.FINISH, handleVideoEnded);
            }
            break;

          case 'streamable':
          case 'gdrive':
          case 'kick':
          case 'iframe':
            const iframeContainer = document.getElementById('iframe-container');
            iframeContainer.classList.add('visible');
            const iframe = document.getElementById('generic-iframe');

            if (platform === 'streamable') iframe.src = `https://streamable.com/e/${id}?autoplay=1`;
            else if (platform === 'gdrive') iframe.src = `https://drive.google.com/file/d/${id}/preview`;
            else if (platform === 'kick') iframe.src = `https://player.kick.com/${id}?autoplay=true`;
            else iframe.src = url; // Generic iframe
            break;

          case 'directUrl':
            // Use main video player
            video.style.display = 'block';
            video.src = url;
            video.play().catch(e => console.error(e));
            break;
        }
      } catch (err) {
        console.error('Error loading external content:', err);
        showTemporaryMessage('Error loading external content', 3000);
      }
    }
    let currentMediaIsYouTube = false;
    let ytApiLoaded = false;

    const socket = io();

    let currentPlaylist = {
      videos: [],
      currentIndex: -1,
      mainVideoIndex: -1,
    };
    let currentVideoInfo = null;
    let mainVideoStartTime = 0;
    let videoLoadAttempts = 0;
    const maxVideoLoadAttempts = 3;
    let lastAppliedAudioTrack = null;
    let lastAppliedSubtitleTrack = null;
    let currentAudioTrack = null;
    let currentSubtitleTrack = null;

    // These will be updated from server config
    let skipSeconds = 5;
    let volumeStep = 0.05;
    let clientControlsDisabled = false; // When true, client controls are view-only

    let lastUpdate = Date.now();
    let hasInitialSync = false; // Prevent new clients from broadcasting until synced

    function showTemporaryMessage(message, duration = 2000) {
      statusEl.textContent = message;
      statusEl.classList.add('visible');
      if (duration > 0) {
        setTimeout(() => statusEl.classList.remove('visible'), duration);
      }
    }

    function showTrackInfo(message, duration = 3000) {
      currentTrackInfoEl.textContent = message;
      currentTrackInfoEl.classList.add('visible');
      setTimeout(() => currentTrackInfoEl.classList.remove('visible'), duration);
    }

    // Send control event to server - ONLY if we have received initial sync
    function sendControlEvent() {
      if (!hasInitialSync) {
        console.log('Skipping control event - waiting for initial sync');
        return;
      }
      socket.emit('control', {
        isPlaying: !video.paused,
        currentTime: video.currentTime,
        duration: video.duration,
        volume: video.volume,
        currentVideoIndex: currentPlaylist.currentIndex,
      });
    }

    // Generate a client fingerprint for identification
    function getClientFingerprint() {
      let stored = localStorage.getItem('client-fingerprint');
      if (stored) return stored;

      const components = [
        navigator.userAgent,
        navigator.language,
        screen.width + 'x' + screen.height,
        new Date().getTimezoneOffset(),
        Math.random().toString(36).slice(2, 8)
      ];
      const str = components.join('|');
      let hash = 0;
      for (let i = 0; i < str.length; i++) {
        hash = ((hash << 5) - hash) + str.charCodeAt(i);
        hash = hash & hash;
      }
      const fp = 'client-' + Math.abs(hash).toString(36);
      localStorage.setItem('client-fingerprint', fp);
      return fp;
    }

    const clientFingerprint = getClientFingerprint();

    socket.on('connect', () => {
      console.log('Connected to server');
      showTemporaryMessage('Connected', 1000);
      socket.emit('request-initial-state');
      // Register with server (for client management)
      socket.emit('client-register', { fingerprint: clientFingerprint });
    });

    socket.on('disconnect', () => {
      console.log('Disconnected from server');
      showTemporaryMessage('Disconnected', 0);
      hasInitialSync = false; // Reset on disconnect
    });

    // Handle config from server
    socket.on('config', (config) => {
      skipSeconds = config.skipSeconds || 5;
      volumeStep = config.volumeStep || 0.05;
      clientControlsDisabled = config.clientControlsDisabled || false;
      console.log(`Config received: skipSeconds=${skipSeconds}, volumeStep=${volumeStep}, clientControlsDisabled=${clientControlsDisabled}`);
      if (clientControlsDisabled) {
        showTemporaryMessage('View-only mode (controls disabled)', 3000);
      }
    });

    // Handle initial state from server
    socket.on('initial-state', (state) => {
      console.log('Received initial state:', state);
      currentPlaylist = state.playlist;
      mainVideoStartTime = state.mainVideoStartTime || 0;

      if (currentPlaylist.videos.length > 0) {
        const videoToPreload = (currentPlaylist.mainVideoIndex >= 0 && currentPlaylist.videos.length > currentPlaylist.mainVideoIndex)
          ? currentPlaylist.videos[currentPlaylist.mainVideoIndex]
          : currentPlaylist.videos[0];
        preloadVideo.src = `/media/${videoToPreload.filename}`;
        preloadVideo.load();
      }

      if (currentPlaylist.videos.length > 0 && currentPlaylist.currentIndex >= 0) {
        waitingMessage.style.display = 'none';
        video.style.display = 'block';
        hasInitialSync = true;
        loadCurrentVideo();
      } else {
        hideAllPlayers();
        waitingMessage.style.display = 'block';
        currentPlatform = 'local';
      }
    });

    socket.on('playlist-position', (index) => {
      currentPlaylist.currentIndex = index;
      if (currentPlaylist.videos.length > 0 && index >= 0) {
        waitingMessage.style.display = 'none';
        video.style.display = 'block';
        hasInitialSync = true;
        loadCurrentVideo();
      } else {
        hideAllPlayers();
        waitingMessage.style.display = 'block';
        currentPlatform = 'local';
      }
    });

    socket.on('playlist-update', (playlist) => {
      console.log('Received playlist update:', playlist);
      currentPlaylist = playlist;

      if (currentPlaylist.videos.length > 0 && currentPlaylist.currentIndex >= 0) {
        waitingMessage.style.display = 'none';
        video.style.display = 'block';
        hasInitialSync = true;
        loadCurrentVideo();
      } else {
        hideAllPlayers();
        waitingMessage.style.display = 'block';
        currentPlatform = 'local';
      }
    });

    socket.on('track-change', (data) => {
      if (currentPlaylist.videos.length > 0 && data.videoIndex < currentPlaylist.videos.length) {
        const videoItem = currentPlaylist.videos[data.videoIndex];

        if (data.type === 'audio') {
          videoItem.selectedAudioTrack = data.trackIndex;
        } else if (data.type === 'subtitle') {
          videoItem.selectedSubtitleTrack = data.trackIndex;
        }

        if (data.videoIndex === currentPlaylist.currentIndex) {
          currentVideoInfo = videoItem;
          applyTrackSelectionsDelayed();

          const trackInfo = data.type === 'audio'
            ? (videoItem.tracks && videoItem.tracks.audio && videoItem.tracks.audio[data.trackIndex]
              ? `${videoItem.tracks.audio[data.trackIndex].language} - ${videoItem.tracks.audio[data.trackIndex].title || `Track ${data.trackIndex}`}`
              : `Audio Track ${data.trackIndex}`)
            : (data.trackIndex >= 0 && videoItem.tracks && videoItem.tracks.subtitles && videoItem.tracks.subtitles[data.trackIndex]
              ? `${videoItem.tracks.subtitles[data.trackIndex].language} - ${videoItem.tracks.subtitles[data.trackIndex].title || `Track ${data.trackIndex}`}`
              : 'Subtitles Off');

          showTrackInfo(`${data.type === 'audio' ? 'Audio' : 'Subtitles'}: ${trackInfo}`);
        }
      }
    });

    video.addEventListener('ended', () => {
      if (currentPlaylist.videos.length > 0) {
        const nextIndex = (currentPlaylist.currentIndex + 1) % currentPlaylist.videos.length;
        socket.emit('playlist-next', nextIndex);
      }
    });

    function loadCurrentVideo() {
      if (currentPlaylist.videos.length === 0 || currentPlaylist.currentIndex < 0) {
        waitingMessage.style.display = 'block';
        video.style.display = 'none';
        return;
      }

      const currentVideo = currentPlaylist.videos[currentPlaylist.currentIndex];
      currentVideoInfo = currentVideo;

      let videoSrc = `/media/${currentVideo.filename}`;
      console.log('Loading video:', videoSrc);
      video.src = videoSrc;

      // Request sync from server to get the current time
      socket.emit('request-sync');

      clearVideoTracks();
      video.load();

      video.onloadeddata = function () {
        videoLoadAttempts = 0;
        applyTrackSelections();

        if (!video.paused) {
          video.play().catch(e => {
            console.log('Playback error:', e);
            handlePlaybackError(e);
          });
        }
      };

      video.onloadedmetadata = function () {
        applyTrackSelections();
      };

      video.onerror = function () {
        console.log('Error loading video:', currentVideo.filename);
        videoLoadAttempts++;

        if (videoLoadAttempts < maxVideoLoadAttempts) {
          setTimeout(() => {
            console.log('Retrying video load, attempt:', videoLoadAttempts);
            loadCurrentVideo();
          }, 1000);
        } else {
          waitingMessage.style.display = 'block';
          video.style.display = 'none';
          showTemporaryMessage('Failed to load video. Please check file format.', 5000);
        }
      };
    }

    function handlePlaybackError(error) {
      console.log('Playback error:', error);
      waitingMessage.style.display = 'block';
      video.style.display = 'none';
      showTemporaryMessage('Playback failed. Please check file format.', 3000);
    }

    function clearVideoTracks() {
      const audioTracks = video.audioTracks;
      const textTracks = video.textTracks;

      if (audioTracks) {
        for (let i = 0; i < audioTracks.length; i++) {
          audioTracks[i].enabled = false;
        }
      }

      if (textTracks) {
        for (let i = 0; i < textTracks.length; i++) {
          textTracks[i].mode = 'disabled';
        }
      }
    }

    function applyTrackSelections() {
      if (!currentVideoInfo) return;
      tryDirectTrackManipulation();
      tryVideoAttributes();
    }

    function tryDirectTrackManipulation() {
      if (typeof video.audioTracks !== 'undefined' && currentVideoInfo.selectedAudioTrack !== undefined) {
        const targetIndex = Math.max(0, Math.min(currentVideoInfo.selectedAudioTrack, video.audioTracks.length - 1));
        if (lastAppliedAudioTrack !== targetIndex) {
          for (let i = 0; i < video.audioTracks.length; i++) {
            video.audioTracks[i].enabled = (i === targetIndex);
          }
          lastAppliedAudioTrack = targetIndex;
        }
      }

      if (typeof video.textTracks !== 'undefined' && currentVideoInfo.selectedSubtitleTrack !== undefined) {
        const targetSubIndex = currentVideoInfo.selectedSubtitleTrack;
        if (lastAppliedSubtitleTrack !== targetSubIndex) {
          for (let i = 0; i < video.textTracks.length; i++) {
            if (targetSubIndex >= 0) {
              video.textTracks[i].mode = (i === targetSubIndex) ? 'showing' : 'disabled';
            } else {
              video.textTracks[i].mode = 'disabled';
            }
          }
          lastAppliedSubtitleTrack = targetSubIndex;
        }
      }
    }

    function tryVideoAttributes() {
      if (currentVideoInfo.selectedAudioTrack !== undefined) {
        video.setAttribute('data-audio-track', currentVideoInfo.selectedAudioTrack);
      }
      if (currentVideoInfo.selectedSubtitleTrack !== undefined) {
        video.setAttribute('data-subtitle-track', currentVideoInfo.selectedSubtitleTrack);
      }
    }

    function applyTrackSelectionsDelayed() {
      setTimeout(() => applyTrackSelections(), 500);
    }

    // Handle sync for external players
    function handleExternalSync(state) {
      if (currentPlatform === 'youtube') {
        if (ytPlayer && ytPlayerReady) {
          const playerState = ytPlayer.getPlayerState();
          if (state.isPlaying && playerState !== YT.PlayerState.PLAYING && playerState !== YT.PlayerState.BUFFERING) ytPlayer.playVideo();
          else if (!state.isPlaying && playerState === YT.PlayerState.PLAYING) ytPlayer.pauseVideo();

          const ytTime = ytPlayer.getCurrentTime();
          if (Math.abs(ytTime - state.currentTime) > 2) {
            ytPlayer.seekTo(state.currentTime, true);
          }
        }
      } else if (currentPlatform === 'vimeo' && vimeoPlayer) {
        vimeoPlayer.getPaused().then(paused => {
          if (state.isPlaying && paused) vimeoPlayer.play().catch(e => { });
          else if (!state.isPlaying && !paused) vimeoPlayer.pause().catch(e => { });
        });
        vimeoPlayer.getCurrentTime().then(t => {
          if (Math.abs(t - state.currentTime) > 2) vimeoPlayer.setCurrentTime(state.currentTime).catch(e => { });
        });
      } else if (currentPlatform === 'twitch' && twitchPlayer) {
        try {
          const player = twitchPlayer.getPlayer ? twitchPlayer.getPlayer() : twitchPlayer;
          if (player) {
            const isPaused = player.isPaused ? player.isPaused() : false;
            if (state.isPlaying && isPaused && player.play) player.play();
            else if (!state.isPlaying && !isPaused && player.pause) player.pause();
          }
        } catch (e) { }
      } else if (currentPlatform === 'dailymotion' && dmPlayer) {
        if (state.isPlaying && dmPlayer.paused) dmPlayer.play();
        else if (!state.isPlaying && !dmPlayer.paused) dmPlayer.pause();
        if (Math.abs(dmPlayer.currentTime - state.currentTime) > 2) dmPlayer.seek(state.currentTime);
      }
    }

    // Handle server sync events
    socket.on('sync', (state) => {
      const now = Date.now();
      if (now - lastUpdate < 100) return;
      lastUpdate = now;

      // Handle external players
      if (currentPlatform && currentPlatform !== 'local' && currentPlatform !== 'directUrl') {
        handleExternalSync(state);
        return;
      }

      // If we receive a sync and have an active playlist, hide waiting message
      if (currentPlaylist.videos.length > 0 && currentPlaylist.currentIndex >= 0) {
        if (waitingMessage.style.display !== 'none') {
          console.log('Hiding waiting message - active playlist detected');
          waitingMessage.style.display = 'none';
          video.style.display = 'block';
          hasInitialSync = true;
        }
      }

      if (state.isPlaying !== !video.paused) {
        if (state.isPlaying) {
          video.play().catch(e => {
            console.log('Playback error:', e);
            handlePlaybackError(e);
          });
        } else {
          video.pause();
          showTemporaryMessage("Paused", 0);
        }
      }

      // Apply BSL-S¬≤ drift if set for current video
      const playlistIdx = currentPlaylist.currentIndex;
      const drift = bslDriftValues[playlistIdx] || 0;
      const targetTime = state.currentTime + drift;  // Positive drift = client ahead, negative = client behind

      if (Math.abs(video.currentTime - targetTime) > 0.5) {
        video.currentTime = Math.max(0, targetTime);  // Don't go negative
      }

      if (state.audioTrack !== undefined && state.audioTrack !== currentAudioTrack) {
        currentAudioTrack = state.audioTrack;
        if (currentVideoInfo && currentVideoInfo.tracks && currentVideoInfo.tracks.audio) {
          const audioTrack = currentVideoInfo.tracks.audio[currentAudioTrack];
          if (audioTrack) {
            showTrackInfo(`Audio: ${audioTrack.language}${audioTrack.title ? ` - ${audioTrack.title}` : ''}`);
          }
        }
      }

      if (state.subtitleTrack !== undefined && state.subtitleTrack !== currentSubtitleTrack) {
        currentSubtitleTrack = state.subtitleTrack;
        if (currentSubtitleTrack >= 0 && currentVideoInfo && currentVideoInfo.tracks && currentVideoInfo.tracks.subtitles) {
          const subtitleTrack = currentVideoInfo.tracks.subtitles[currentSubtitleTrack];
          if (subtitleTrack) {
            showTrackInfo(`Subtitles: ${subtitleTrack.language}${subtitleTrack.title ? ` - ${subtitleTrack.title}` : ''}`);
          }
        } else if (currentSubtitleTrack < 0) {
          showTrackInfo("Subtitles: Off");
        }
      }
    });

    // Event listeners - only send control if we have initial sync
    video.addEventListener('play', () => {
      statusEl.classList.remove('visible');
      sendControlEvent();
    });

    video.addEventListener('pause', () => {
      showTemporaryMessage("Paused", 0);
      sendControlEvent();
    });

    video.addEventListener('seeked', sendControlEvent);

    // Control zones (click on screen)
    document.addEventListener('click', (e) => {
      // Skip if controls are disabled by admin
      if (clientControlsDisabled) return;

      // Skip if YouTube is playing - it has its own click handler
      if (currentMediaIsYouTube) return;

      const w = window.innerWidth;
      const x = e.clientX;
      const center = w / 2;
      const edgeZone = 87;
      const pauseZone = 75;

      if (x <= edgeZone) {
        // If viewing an image, go to previous media
        if (currentMediaIsImage) {
          if (currentPlaylist.currentIndex > 0) {
            const prevIndex = currentPlaylist.currentIndex - 1;
            socket.emit('playlist-jump', prevIndex);
            showTemporaryMessage(`‚èÆ Previous media`);
          } else {
            showTemporaryMessage(`Already at first item`);
          }
        } else {
          video.currentTime = Math.max(0, video.currentTime - skipSeconds);
          showTemporaryMessage(`‚Ü© Rewind ${skipSeconds}s`);
          sendControlEvent();
        }
      } else if (x >= w - edgeZone) {
        // If viewing an image, go to next media
        if (currentMediaIsImage) {
          if (currentPlaylist.currentIndex < currentPlaylist.videos.length - 1) {
            const nextIndex = currentPlaylist.currentIndex + 1;
            socket.emit('playlist-jump', nextIndex);
            showTemporaryMessage(`‚è≠ Next media`);
          } else {
            showTemporaryMessage(`Already at last item`);
          }
        } else {
          video.currentTime = Math.min(video.duration, video.currentTime + skipSeconds);
          showTemporaryMessage(`‚Ü™ Skip ${skipSeconds}s`);
          sendControlEvent();
        }
      } else if (x >= center - pauseZone && x <= center + pauseZone) {
        if (video.paused) {
          video.play();
        } else {
          video.pause();
        }
      } else if (x < center) {
        video.volume = Math.max(0, video.volume - volumeStep);
        showTemporaryMessage(`Volume: ${Math.round(video.volume * 100)}%`);
      } else {
        video.volume = Math.min(1, video.volume + volumeStep);
        showTemporaryMessage(`Volume: ${Math.round(video.volume * 100)}%`);
      }
    });

    // Auto-reconnect
    setInterval(() => {
      if (!socket.connected) {
        socket.connect();
        showTemporaryMessage("Reconnecting...");
      }
    }, 5000);

    // ==================== BSL-S¬≤ (Both Side Local Sync Stream) ====================

    // Generate machine fingerprint based on hardware/browser characteristics
    function generateMachineFingerprint() {
      const components = [
        navigator.userAgent,
        navigator.language,
        navigator.platform,
        navigator.hardwareConcurrency || 'unknown',
        navigator.deviceMemory || 'unknown',
        screen.width + 'x' + screen.height,
        screen.colorDepth,
        new Date().getTimezoneOffset(),
        // Canvas fingerprint for additional uniqueness
        (() => {
          try {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            ctx.textBaseline = 'top';
            ctx.font = '14px Arial';
            ctx.fillText('BSL-S¬≤ fingerprint', 2, 2);
            return canvas.toDataURL().slice(-50);
          } catch (e) {
            return 'no-canvas';
          }
        })()
      ];

      // Simple hash function
      const str = components.join('|');
      let hash = 0;
      for (let i = 0; i < str.length; i++) {
        const char = str.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash; // Convert to 32bit integer
      }
      return 'machine-' + Math.abs(hash).toString(36);
    }

    // Get or generate client fingerprint and display name
    function getClientIdentity() {
      // Generate fingerprint (may change slightly across browsers but stable within same browser)
      const fingerprint = generateMachineFingerprint();

      // Get stored fingerprint - use it if exists, otherwise use new one
      let storedFingerprint = localStorage.getItem('bsl-machine-fingerprint');
      let clientId;

      if (storedFingerprint) {
        // Use stored fingerprint for consistency
        clientId = storedFingerprint;
        console.log('BSL-S¬≤: Using stored machine fingerprint:', clientId);
      } else {
        // Store the new fingerprint
        clientId = fingerprint;
        localStorage.setItem('bsl-machine-fingerprint', clientId);
        console.log('BSL-S¬≤: Generated new machine fingerprint:', clientId);
      }

      // Get or set default display name
      let displayName = localStorage.getItem('bsl-client-name');
      if (!displayName) {
        displayName = 'Client-' + clientId.slice(-6);
        localStorage.setItem('bsl-client-name', displayName);
      }

      return { clientId, displayName };
    }

    const bslIdentity = getClientIdentity();
    const bslClientId = bslIdentity.clientId;
    let bslClientName = bslIdentity.displayName;

    // Allow updating client name
    function setBslClientName(newName) {
      bslClientName = newName;
      localStorage.setItem('bsl-client-name', newName);
      console.log('BSL-S¬≤: Client name updated to:', newName);
    }

    // BSL-S¬≤ state
    const bslLocalFiles = new Map(); // filename -> File object
    const bslBlobUrls = new Map();   // filename -> blob URL
    let bslMatchedVideos = {};       // playlistIndex -> localFileName
    let bslDriftValues = {};         // playlistIndex -> drift seconds (offset for sync)

    const bslOverlay = document.getElementById('bsl-overlay');
    const bslFolderInput = document.getElementById('bsl-folder-input');
    const bslSelectBtn = document.getElementById('bsl-select-btn');
    const bslUsePreviousBtn = document.getElementById('bsl-use-previous-btn');
    const bslResultDiv = document.getElementById('bsl-result');

    // Get cached BSL folder data from localStorage
    function getCachedBslFiles() {
      try {
        const cached = localStorage.getItem('bsl-cached-files');
        if (cached) {
          return JSON.parse(cached);
        }
      } catch (e) {
        console.error('Error reading cached BSL files:', e);
      }
      return null;
    }

    // Save BSL files to localStorage
    function cacheBslFiles(files) {
      try {
        localStorage.setItem('bsl-cached-files', JSON.stringify(files));
        console.log('BSL-S¬≤: Cached file list for future sessions');
      } catch (e) {
        console.error('Error caching BSL files:', e);
      }
    }

    // Handle admin BSL-S¬≤ check request
    socket.on('bsl-check-request', (data) => {
      console.log('BSL-S¬≤ check requested by admin', data);
      showTemporaryMessage('Admin is checking for local videos...', 3000);

      // Check if we have cached files from previous session
      const cachedFiles = getCachedBslFiles();
      if (cachedFiles && cachedFiles.length > 0) {
        bslUsePreviousBtn.style.display = 'inline-block';
        bslUsePreviousBtn.textContent = `Use Previous (${cachedFiles.length} files)`;
      } else {
        bslUsePreviousBtn.style.display = 'none';
      }

      // Show the folder selection overlay
      bslOverlay.classList.add('visible');
      bslResultDiv.style.display = 'none';
    });

    // Handle Use Previous Folder button
    bslUsePreviousBtn.addEventListener('click', () => {
      const cachedFiles = getCachedBslFiles();
      if (cachedFiles && cachedFiles.length > 0) {
        console.log(`BSL-S¬≤: Using ${cachedFiles.length} cached files from previous session`);

        // Send cached file list to server
        socket.emit('bsl-folder-selected', {
          clientId: bslClientId,
          clientName: bslClientName,
          files: cachedFiles,
          fromCache: true
        });

        // Update UI
        bslSelectBtn.textContent = `${cachedFiles.length} videos (cached)`;
        bslSelectBtn.disabled = true;
        bslUsePreviousBtn.style.display = 'none';
        showTemporaryMessage(`Using ${cachedFiles.length} cached files`, 2000);
      }
    });

    // Handle folder selection button click
    bslSelectBtn.addEventListener('click', () => {
      bslFolderInput.click();
    });

    // Handle skip button click
    const bslSkipBtn = document.getElementById('bsl-skip-btn');
    bslSkipBtn.addEventListener('click', () => {
      console.log('BSL-S¬≤: User skipped folder selection');
      bslOverlay.classList.remove('visible');
      showTemporaryMessage('BSL-S¬≤: Skipped - streaming from server', 2000);

      // Notify server that this client declined
      socket.emit('bsl-folder-selected', {
        clientId: bslClientId,
        clientName: bslClientName,
        files: [],
        skipped: true
      });
    });

    // Handle folder selection
    bslFolderInput.addEventListener('change', (e) => {
      const files = e.target.files;
      if (!files || files.length === 0) return;

      console.log(`BSL-S¬≤: Selected folder with ${files.length} files`);

      // Clear previous data
      bslLocalFiles.clear();

      // Filter for video files and store them
      const videoExtensions = ['.mp4', '.mp3', '.avi', '.mov', '.wmv', '.mkv', '.webm', '.png', '.jpg', '.jpeg', '.webp'];
      const videoFiles = [];

      for (const file of files) {
        const ext = file.name.substring(file.name.lastIndexOf('.')).toLowerCase();
        if (videoExtensions.includes(ext)) {
          bslLocalFiles.set(file.name.toLowerCase(), file);
          videoFiles.push({
            name: file.name,
            size: file.size,
            type: file.type
          });
        }
      }

      console.log(`BSL-S¬≤: Found ${videoFiles.length} video files`);

      // Send file list to server with client ID and name
      socket.emit('bsl-folder-selected', {
        clientId: bslClientId,
        clientName: bslClientName,
        files: videoFiles
      });

      // Cache file list for future sessions
      cacheBslFiles(videoFiles);

      // Update UI
      bslSelectBtn.textContent = `${videoFiles.length} videos found`;
      bslSelectBtn.disabled = true;
      bslUsePreviousBtn.style.display = 'none';
    });

    // Handle match results from server
    socket.on('bsl-match-result', (data) => {
      console.log('BSL-S¬≤ match results:', data);
      bslMatchedVideos = data.matchedVideos;

      // Create blob URLs for matched files
      Object.entries(bslMatchedVideos).forEach(([playlistIdx, localFileName]) => {
        const file = bslLocalFiles.get(localFileName.toLowerCase());
        if (file && !bslBlobUrls.has(localFileName.toLowerCase())) {
          const blobUrl = URL.createObjectURL(file);
          bslBlobUrls.set(localFileName.toLowerCase(), blobUrl);
          console.log(`BSL-S¬≤: Created blob URL for ${localFileName}`);
        }
      });

      // Update UI with results
      bslResultDiv.style.display = 'block';
      if (data.totalMatched === data.totalPlaylist) {
        bslResultDiv.className = 'bsl-result success';
        bslResultDiv.textContent = `‚úì All ${data.totalMatched} videos matched! Local playback enabled.`;
      } else if (data.totalMatched > 0) {
        bslResultDiv.className = 'bsl-result partial';
        bslResultDiv.textContent = `${data.totalMatched}/${data.totalPlaylist} videos matched locally.`;
      } else {
        bslResultDiv.className = 'bsl-result';
        bslResultDiv.textContent = `No matching videos found. Streaming from server.`;
      }

      // Auto-hide overlay after a delay
      setTimeout(() => {
        bslOverlay.classList.remove('visible');
        showTemporaryMessage(`BSL-S¬≤: ${data.totalMatched} videos will play locally`, 3000);
      }, 2000);
    });

    // Handle drift updates from server
    socket.on('bsl-drift-update', (data) => {
      console.log('BSL-S¬≤ drift update:', data);
      bslDriftValues = data.driftValues || {};
      showTemporaryMessage('Drift settings updated', 2000);
    });

    // Helper: Check if current video should use local playback
    function getBslLocalUrl(filename) {
      // Find if this video is matched
      const playlistIdx = currentPlaylist.currentIndex;
      const matchedFileName = bslMatchedVideos[playlistIdx];

      if (matchedFileName) {
        const blobUrl = bslBlobUrls.get(matchedFileName.toLowerCase());
        if (blobUrl) {
          console.log(`BSL-S¬≤: Using local file for ${filename}`);
          return blobUrl;
        }
      }
      return null;
    }

    // Override video source selection in loadCurrentVideo
    // This is done by modifying the existing loadCurrentVideo function's behavior
    const originalLoadCurrentVideo = loadCurrentVideo;
    loadCurrentVideo = function () {
      if (currentPlaylist.videos.length === 0 || currentPlaylist.currentIndex < 0) {
        waitingMessage.style.display = 'block';
        video.style.display = 'none';
        imageDisplay.style.display = 'none';
        currentMediaIsImage = false;
        return;
      }

      const currentVideo = currentPlaylist.videos[currentPlaylist.currentIndex];
      currentVideoInfo = currentVideo;

      // Check if this is external content
      if (currentVideo.isExternal || currentVideo.isYouTube) {
        currentMediaIsImage = false;
        waitingMessage.style.display = 'none';

        // Use the unified loader
        const platform = currentVideo.platform || (currentVideo.isYouTube ? 'youtube' : 'local');
        const id = currentVideo.externalId || currentVideo.youtubeId;
        const url = currentVideo.externalUrl;

        mediaPlaceholder.style.display = 'none'; // Ensure placeholder hidden for external content

        loadExternalContent(platform, id, url);

        showTemporaryMessage(`${currentVideo.platformName || 'External'} content loaded`, 2000);
        return;
      }

      // Hide all external player containers when switching to local content
      hideAllPlayers();
      currentPlatform = 'local';

      // Check if this is an image file
      if (isImageFile(currentVideo.filename)) {
        currentMediaIsImage = true;

        // Hide video, show image
        video.style.display = 'none';
        video.pause();

        // Check for BSL-S¬≤ local playback
        const localUrl = getBslLocalUrl(currentVideo.filename);
        let imageSrc;

        if (localUrl) {
          imageSrc = localUrl;
          console.log('BSL-S¬≤: Loading IMAGE from LOCAL file');
          showTemporaryMessage('üñºÔ∏è Displaying local image (BSL-S¬≤)', 2000);
        } else {
          imageSrc = `/media/${currentVideo.filename}`;
          console.log('Loading image from server:', imageSrc);
        }

        imageDisplay.src = imageSrc;
        imageDisplay.style.display = 'block';
        waitingMessage.style.display = 'none';

        showTemporaryMessage(`üñºÔ∏è Image - tap edges to skip`, 3000);
        return;
      }

      // It's a video or audio file
      currentMediaIsImage = false;

      // Check if it's an audio file and handle display
      if (isAudioFile(currentVideo.filename)) {
        imageDisplay.style.display = 'block';
        // Use the thumbnail API which extracts embedded cover art
        imageDisplay.src = `/api/thumbnail/${encodeURIComponent(currentVideo.filename)}`;

        // Hide broken image if no cover art found
        imageDisplay.onerror = function () {
          this.style.display = 'none';
          mediaPlaceholder.style.display = 'flex';
          showTemporaryMessage('üéµ Playing Audio', 3000);
        };

        video.style.display = 'none';
      } else {
        imageDisplay.style.display = 'none';
        mediaPlaceholder.style.display = 'none';
        video.style.display = 'block';
      }

      // Check for BSL-S¬≤ local playback
      const localUrl = getBslLocalUrl(currentVideo.filename);
      let videoSrc;

      if (localUrl) {
        videoSrc = localUrl;
        console.log('BSL-S¬≤: Loading from LOCAL file');
        const msg = isAudioFile(currentVideo.filename) ? 'üìÅ Playing local audio (BSL-S¬≤)' : 'üìÅ Playing local video (BSL-S¬≤)';
        showTemporaryMessage(msg, 2000);
      } else {
        videoSrc = `/media/${currentVideo.filename}`;
        console.log('Loading media from server:', videoSrc);
      }

      video.src = videoSrc;

      // Request sync from server to get the current time
      socket.emit('request-sync');

      clearVideoTracks();
      video.load();

      video.onloadeddata = function () {
        videoLoadAttempts = 0;
        applyTrackSelections();

        if (!video.paused) {
          video.play().catch(e => {
            console.log('Playback error:', e);
            handlePlaybackError(e);
          });
        }
      };

      video.onloadedmetadata = function () {
        applyTrackSelections();
      };

      video.onerror = function () {
        console.log('Error loading video:', currentVideo.filename);
        videoLoadAttempts++;

        if (videoLoadAttempts < maxVideoLoadAttempts) {
          setTimeout(() => {
            console.log('Retrying video load, attempt:', videoLoadAttempts);
            loadCurrentVideo();
          }, 1000);
        } else {
          waitingMessage.style.display = 'block';
          video.style.display = 'none';
          showTemporaryMessage('Failed to load video. Please check file format.', 5000);
        }
      };
    };

    // ==================== YouTube IFrame API Integration ====================

    // Load YouTube IFrame API
    function loadYouTubeAPI() {
      if (ytApiLoaded) return Promise.resolve();

      return new Promise((resolve) => {
        if (window.YT && window.YT.Player) {
          ytApiLoaded = true;
          resolve();
          return;
        }

        const tag = document.createElement('script');
        tag.src = 'https://www.youtube.com/iframe_api';
        const firstScriptTag = document.getElementsByTagName('script')[0];
        firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);

        window.onYouTubeIframeAPIReady = () => {
          ytApiLoaded = true;
          resolve();
        };
      });
    }

    // Initialize YouTube player with a video ID
    function initYouTubePlayer(videoId) {
      return new Promise((resolve) => {
        // Destroy existing player if any
        if (ytPlayer) {
          try {
            ytPlayer.destroy();
          } catch (e) {
            console.log('Error destroying previous player:', e);
          }
          ytPlayer = null;
          ytPlayerReady = false;
        }

        // Reset the "has played" flag for the new video
        ytVideoHasPlayed = false;

        ytPlayer = new YT.Player('youtube-player', {
          videoId: videoId,
          playerVars: {
            'controls': 0,           // Hide YouTube controls (this works)
            'disablekb': 1,          // Disable keyboard controls
            'rel': 0,                // Don't show related videos at end
            'fs': 0,                 // Disable fullscreen button
            'iv_load_policy': 3,     // Hide annotations
            'playsinline': 1,        // Play inline on mobile
            'cc_load_policy': 0,     // Don't show captions by default
            'autoplay': 1,           // Auto-play when ready
            'origin': window.location.origin
            // NOTE: 'modestbranding' was deprecated Aug 2023
            // NOTE: 'showinfo' was deprecated Sep 2018
          },
          events: {
            'onReady': (event) => {
              ytPlayerReady = true;
              console.log('YouTube player ready');

              // Auto-play if this is not the first video in playlist
              // (first video follows server sync, subsequent videos should auto-continue)
              if (currentPlaylist.currentIndex > 0) {
                event.target.playVideo();
              }

              resolve(event.target);
            },
            'onStateChange': (event) => {
              handleYouTubeStateChange(event);
            },
            'onError': (event) => {
              console.error('YouTube player error:', event.data);
              showTemporaryMessage('YouTube playback error', 3000);
            }
          }
        });
      });
    }

    // Track if YouTube video has actually started playing (to prevent false ENDED states)
    // ytVideoHasPlayed is defined at the top of the script
    // let ytVideoHasPlayed = false;

    // Handle YouTube player state changes
    function handleYouTubeStateChange(event) {
      if (!ytPlayerReady) return;

      // YT.PlayerState: UNSTARTED=-1, ENDED=0, PLAYING=1, PAUSED=2, BUFFERING=3, CUED=5
      switch (event.data) {
        case YT.PlayerState.PLAYING:
          ytVideoHasPlayed = true; // Video has started playing at least once
          statusEl.classList.remove('visible');
          sendYouTubeControlEvent();
          break;
        case YT.PlayerState.PAUSED:
          showTemporaryMessage("Paused", 0);
          sendYouTubeControlEvent();
          break;
        case YT.PlayerState.BUFFERING:
          showTemporaryMessage("Loading...", 0);
          break;
        case YT.PlayerState.ENDED:
          // Only move to next if the video actually played first
          // This prevents skipping when video is still loading
          if (ytVideoHasPlayed && currentPlaylist.videos.length > 0) {
            const nextIndex = (currentPlaylist.currentIndex + 1) % currentPlaylist.videos.length;
            socket.emit('playlist-next', nextIndex);
            ytVideoHasPlayed = false; // Reset for next video
          }
          break;
      }
    }

    // Send control event for YouTube
    function sendYouTubeControlEvent() {
      if (!hasInitialSync || !ytPlayer || !ytPlayerReady) return;

      try {
        const playerState = ytPlayer.getPlayerState();
        const isPlaying = playerState === YT.PlayerState.PLAYING;
        const currentTime = ytPlayer.getCurrentTime() || 0;

        socket.emit('control', {
          isPlaying: isPlaying,
          currentTime: currentTime,
          duration: ytPlayer.getDuration() || 0,
          volume: ytPlayer.getVolume() / 100,
          currentVideoIndex: currentPlaylist.currentIndex,
        });
      } catch (e) {
        console.log('Error sending YouTube control event:', e);
      }
    }

    // Apply sync state to YouTube player
    function syncYouTubePlayer(state) {
      if (!ytPlayer || !ytPlayerReady) return;

      try {
        const playerState = ytPlayer.getPlayerState();
        const isCurrentlyPlaying = playerState === YT.PlayerState.PLAYING;

        // Sync play/pause
        if (state.isPlaying && !isCurrentlyPlaying) {
          ytPlayer.playVideo();
        } else if (!state.isPlaying && isCurrentlyPlaying) {
          ytPlayer.pauseVideo();
          showTemporaryMessage("Paused", 0);
        }

        // Sync time (with 1 second tolerance)
        const currentTime = ytPlayer.getCurrentTime() || 0;
        if (Math.abs(currentTime - state.currentTime) > 1) {
          ytPlayer.seekTo(state.currentTime, true);
        }
      } catch (e) {
        console.log('Error syncing YouTube player:', e);
      }
    }

    // Override the loadCurrentVideo to handle YouTube
    const originalLoadWithBsl = loadCurrentVideo;
    loadCurrentVideo = async function () {
      if (currentPlaylist.videos.length === 0 || currentPlaylist.currentIndex < 0) {
        hideAllPlayers();
        waitingMessage.style.display = 'block';
        currentMediaIsImage = false;
        currentMediaIsYouTube = false;
        currentPlatform = 'local';
        return;
      }

      const currentVideo = currentPlaylist.videos[currentPlaylist.currentIndex];
      currentVideoInfo = currentVideo;

      // Check if this is a YouTube video
      if (currentVideo.isYouTube && currentVideo.youtubeId) {
        currentMediaIsYouTube = true;
        currentMediaIsImage = false;
        currentPlatform = 'youtube';

        // Hide all other players (including other external platforms)
        hideAllPlayers();

        // Show YouTube container
        youtubeContainer.classList.add('visible');
        waitingMessage.style.display = 'none';

        console.log('Loading YouTube video:', currentVideo.youtubeId);
        showTemporaryMessage('üì∫ Loading YouTube video...', 2000);

        // Load YouTube API if needed, then initialize player
        await loadYouTubeAPI();
        await initYouTubePlayer(currentVideo.youtubeId);

        // Request sync from server
        socket.emit('request-sync');

        showTemporaryMessage('üì∫ YouTube - tap to control', 3000);
        return;
      }

      // Not YouTube - hide YouTube container
      currentMediaIsYouTube = false;
      youtubeContainer.classList.remove('visible');

      // Destroy YouTube player if exists
      if (ytPlayer) {
        try {
          ytPlayer.destroy();
        } catch (e) { }
        ytPlayer = null;
        ytPlayerReady = false;
      }

      // Call the original function for local videos/images
      originalLoadWithBsl.call(this);
    };

    // Modified sync handler to support YouTube
    const originalSyncHandler = socket._callbacks['$sync'];
    socket.off('sync');
    socket.on('sync', (state) => {
      const now = Date.now();
      if (now - lastUpdate < 100) return;
      lastUpdate = now;

      // If we receive a sync and have an active playlist, hide waiting message
      if (currentPlaylist.videos.length > 0 && currentPlaylist.currentIndex >= 0) {
        if (waitingMessage.style.display !== 'none') {
          console.log('Hiding waiting message - active playlist detected');
          waitingMessage.style.display = 'none';
          hasInitialSync = true;

          if (currentMediaIsYouTube) {
            youtubeContainer.classList.add('visible');
          } else {
            video.style.display = 'block';
          }
        }
      }

      // Handle YouTube sync
      if (currentMediaIsYouTube) {
        syncYouTubePlayer(state);
        return;
      }

      // Normal video sync
      if (state.isPlaying !== !video.paused) {
        if (state.isPlaying) {
          video.play().catch(e => {
            console.log('Playback error:', e);
            handlePlaybackError(e);
          });
        } else {
          video.pause();
          showTemporaryMessage("Paused", 0);
        }
      }

      if (Math.abs(video.currentTime - state.currentTime) > 0.5) {
        video.currentTime = state.currentTime;
      }

      if (state.audioTrack !== undefined && state.audioTrack !== currentAudioTrack) {
        currentAudioTrack = state.audioTrack;
        if (currentVideoInfo && currentVideoInfo.tracks && currentVideoInfo.tracks.audio) {
          const audioTrack = currentVideoInfo.tracks.audio[currentAudioTrack];
          if (audioTrack) {
            showTrackInfo(`Audio: ${audioTrack.language}${audioTrack.title ? ` - ${audioTrack.title}` : ''}`);
          }
        }
      }

      if (state.subtitleTrack !== undefined && state.subtitleTrack !== currentSubtitleTrack) {
        currentSubtitleTrack = state.subtitleTrack;
        if (currentSubtitleTrack >= 0 && currentVideoInfo && currentVideoInfo.tracks && currentVideoInfo.tracks.subtitles) {
          const subtitleTrack = currentVideoInfo.tracks.subtitles[currentSubtitleTrack];
          if (subtitleTrack) {
            showTrackInfo(`Subtitles: ${subtitleTrack.language}${subtitleTrack.title ? ` - ${subtitleTrack.title}` : ''}`);
          }
        } else if (currentSubtitleTrack < 0) {
          showTrackInfo("Subtitles: Off");
        }
      }
    });

    // Click handler for YouTube overlay (use sync-player controls)
    youtubeClickOverlay.addEventListener('click', (e) => {
      // Skip if controls are disabled by admin
      if (clientControlsDisabled) return;

      if (!currentMediaIsYouTube || !ytPlayer || !ytPlayerReady) return;

      const w = window.innerWidth;
      const x = e.clientX;
      const center = w / 2;
      const edgeZone = 87;
      const pauseZone = 75;

      try {
        if (x <= edgeZone) {
          // Rewind
          const currentTime = ytPlayer.getCurrentTime() || 0;
          ytPlayer.seekTo(Math.max(0, currentTime - skipSeconds), true);
          showTemporaryMessage(`‚Ü© Rewind ${skipSeconds}s`);
          sendYouTubeControlEvent();
        } else if (x >= w - edgeZone) {
          // Skip forward
          const currentTime = ytPlayer.getCurrentTime() || 0;
          const duration = ytPlayer.getDuration() || 0;
          ytPlayer.seekTo(Math.min(duration, currentTime + skipSeconds), true);
          showTemporaryMessage(`‚Ü™ Skip ${skipSeconds}s`);
          sendYouTubeControlEvent();
        } else if (x >= center - pauseZone && x <= center + pauseZone) {
          // Play/Pause
          const playerState = ytPlayer.getPlayerState();
          if (playerState === YT.PlayerState.PLAYING) {
            ytPlayer.pauseVideo();
          } else {
            ytPlayer.playVideo();
          }
        } else if (x < center) {
          // Volume down (left side between edge and center)
          const currentVol = ytPlayer.getVolume() || 0;
          const newVol = Math.max(0, currentVol - (volumeStep * 100));
          ytPlayer.setVolume(newVol);
          showTemporaryMessage(`Volume: ${Math.round(newVol)}%`);
        } else {
          // Volume up (right side between edge and center)
          const currentVol = ytPlayer.getVolume() || 0;
          const newVol = Math.min(100, currentVol + (volumeStep * 100));
          ytPlayer.setVolume(newVol);
          showTemporaryMessage(`Volume: ${Math.round(newVol)}%`);
        }
      } catch (e) {
        console.log('Error handling YouTube click:', e);
      }
    });
  </script>
</body>

</html>
